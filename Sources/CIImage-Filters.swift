//
// Automatically generated by CIImage-Generation.swift - do not edit
//

import Foundation
import CoreImage
import CoreImage.CIFilterBuiltins
import CoreML
import AVFoundation

public extension CIImage {

	//
	// MARK: IMAGE-TO-IMAGE FILTERS
	//

	/// Accordion Fold Transition
	///
	/// Transitions from one image to another of differing dimensions by unfolding and crossfading.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIAccordionFoldTransition)
	///
	/// Categories: Transition, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - targetImage: The target image for a transition.
	///   - bottomHeight: The height in pixels from the bottom of the image to the bottom of the folded part of the transition. (0...)
	///   - numberOfFolds: The number of folds used in the transition. (1...50)
	///   - foldShadowAmount: A value that specifies the intensity of the shadow in the transition. (0...1)
	///   - time: The duration of the effect. (0...1)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func accordionFoldTransition(targetImage: CIImage,
								 bottomHeight: Float = 0,
								 numberOfFolds: Float = 3,
								 foldShadowAmount: Float = 0.1,
								 time: Float,
								 active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.accordionFoldTransition() // CIAccordionFoldTransition
		filter.inputImage = self
		filter.targetImage = targetImage
		filter.bottomHeight = bottomHeight
		filter.numberOfFolds = numberOfFolds
		filter.foldShadowAmount = foldShadowAmount
		filter.time = time
		return filter.outputImage ?? CIImage.empty()
	}

	/// Addition
	///
	/// Adds color components to achieve a brightening effect. This filter is typically used to add highlights and lens flare effects.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIAdditionCompositing)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func additionCompositing(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.additionCompositing() // CIAdditionCompositing
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Affine Clamp
	///
	/// Performs an affine transformation on a source image and then clamps the pixels at the edge of the transformed image, extending them outwards. This filter performs similarly to the “Affine Transform” filter except that it produces an image with infinite extent. You can use this filter when you need to blur an image but you want to avoid a soft, black fringe along the edges.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIAffineClamp)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - transform: The transform to apply to the image.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func affineClamp(transform: CGAffineTransform = CGAffineTransform.identity) -> CIImage {
		guard transform != CGAffineTransform.identity else { return self }

		let filter = CIFilter.affineClamp() // CIAffineClamp
		filter.inputImage = self
		filter.transform = transform
		return filter.outputImage ?? CIImage.empty()
	}

	/// Affine Tile
	///
	/// Applies an affine transformation to an image and then tiles the transformed image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIAffineTile)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - transform: The transform to apply to the image.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func affineTile(transform: CGAffineTransform = CGAffineTransform.identity) -> CIImage {
		guard transform != CGAffineTransform.identity else { return self }

		let filter = CIFilter.affineTile() // CIAffineTile
		filter.inputImage = self
		filter.transform = transform
		return filter.outputImage ?? CIImage.empty()
	}

	// NOTE: CIAffineTransform already has a CIImage method: func transformed(by: CGAffineTransform) -> CIImage


	/// Area Average
	///
	/// Calculates the average color for the specified area in an image, returning the result in a pixel.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIAreaAverage)
	///
	/// Categories: Reduction, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that specifies the subregion of the image that you want to process.
	///   - active: should this filter be applied
	/// - Returns: a single-pixel image  that contains the average color for the region of interest, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func areaAverage(extent: CGRect, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.areaAverage() // CIAreaAverage
		filter.inputImage = self
		filter.extent = extent
		return filter.outputImage ?? CIImage.empty()
	}

	/// Area Histogram
	///
	/// Calculates histograms of the R, G, B, and A channels of the specified area of an image. The output image is a one pixel tall image containing the histogram data for all four channels.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIAreaHistogram)
	///
	/// Categories: Reduction, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that, after intersection with the image extent, specifies the subregion of the image that you want to process.
	///   - scale: The scale value to use for the histogram values. If the scale is 1.0, then the bins in the resulting image will add up to 1.0. (0...)
	///   - count: The number of bins for the histogram. This value will determine the width of the output image. (1...2048)
	///   - active: should this filter be applied
	/// - Returns: a 1D image (inputCount wide by one pixel high) that contains the component-wise histogram computed for the specified rectangular area, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func areaHistogram(extent: CGRect, scale: Float = 1, count: Int = 64, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.areaHistogram() // CIAreaHistogram
		filter.inputImage = self
		filter.extent = extent
		filter.scale = scale
		filter.count = count
		return filter.outputImage ?? CIImage.empty()
	}

	/// Area Logarithmic Histogram
	///
	/// Calculates histogram of the R, G, B, and A channels of the specified area of an image. Before binning, the R, G, and B channel values are transformed by the log base two function. The output image is a one pixel tall image containing the histogram data for all four channels.
	///
	/// ⚠️ No Apple Documentation available for 'CIAreaLogarithmicHistogram'
	///
	/// Categories: Reduction, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that defines the extent of the effect.
	///   - scale: The amount of the effect. (0...)
	///   - count: The number of bins for the histogram. This value will determine the width of the output image. (1...2048)
	///   - minimumStop: The minimum of the range of color channel values to be in the logarithmic histogram image.
	///   - maximumStop: The maximum of the range of color channel values to be in the logarithmic histogram image.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 16, macOS 13.0, *)
	func areaLogarithmicHistogram(extent: CGRect,
								  scale: Float = 1,
								  count: Int = 64,
								  minimumStop: Float = -10,
								  maximumStop: Float = 4,
								  active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.areaLogarithmicHistogram() // CIAreaLogarithmicHistogram
		filter.inputImage = self
		filter.extent = extent
		filter.scale = scale
		filter.count = count
		filter.minimumStop = minimumStop
		filter.maximumStop = maximumStop
		return filter.outputImage ?? CIImage.empty()
	}

	/// Area Maximum
	///
	/// Calculates the maximum component values for the specified area in an image, returning the result in a pixel.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIAreaMaximum)
	///
	/// Categories: Reduction, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that specifies the subregion of the image that you want to process.
	///   - active: should this filter be applied
	/// - Returns: a single-pixel image that contains the maximum color components for the region of interest, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func areaMaximum(extent: CGRect, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.areaMaximum() // CIAreaMaximum
		filter.inputImage = self
		filter.extent = extent
		return filter.outputImage ?? CIImage.empty()
	}

	/// Area Maximum Alpha
	///
	/// Finds and returns the pixel with the maximum alpha value.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIAreaMaximumAlpha)
	///
	/// Categories: Reduction, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that specifies the subregion of the image that you want to process.
	///   - active: should this filter be applied
	/// - Returns: a single-pixel image that contains the color vector with the maximum alpha value for the region of interest, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func areaMaximumAlpha(extent: CGRect, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.areaMaximumAlpha() // CIAreaMaximumAlpha
		filter.inputImage = self
		filter.extent = extent
		return filter.outputImage ?? CIImage.empty()
	}

	/// Area Min and Max
	///
	/// Calculates the per-component minimum and maximum value for the specified area in an image. The result is returned in a 2x1 image where the component minimum values are stored in the pixel on the left.
	///
	/// ⚠️ No Apple Documentation available for 'CIAreaMinMax'
	///
	/// Categories: Reduction, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that specifies the subregion of the image that you want to process.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func areaMinMax(extent: CGRect, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.areaMinMax() // CIAreaMinMax
		filter.inputImage = self
		filter.extent = extent
		return filter.outputImage ?? CIImage.empty()
	}

	/// Area Min and Max Red
	///
	/// Calculates the minimum and maximum red component value for the specified area in an image. The result is returned in the red and green channels of a one pixel image.
	///
	/// ⚠️ No Apple Documentation available for 'CIAreaMinMaxRed'
	///
	/// Categories: Reduction, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that specifies the subregion of the image that you want to process.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func areaMinMaxRed(extent: CGRect, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.areaMinMaxRed() // CIAreaMinMaxRed
		filter.inputImage = self
		filter.extent = extent
		return filter.outputImage ?? CIImage.empty()
	}

	/// Area Minimum
	///
	/// Calculates the minimum component values for the specified area in an image, returning the result in a pixel.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIAreaMinimum)
	///
	/// Categories: Reduction, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that specifies the subregion of the image that you want to process.
	///   - active: should this filter be applied
	/// - Returns: a single-pixel image that contains the minimum color components for the region of interest, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func areaMinimum(extent: CGRect, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.areaMinimum() // CIAreaMinimum
		filter.inputImage = self
		filter.extent = extent
		return filter.outputImage ?? CIImage.empty()
	}

	/// Area Minimum Alpha
	///
	/// Finds and returns the pixel with the minimum alpha value.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIAreaMinimumAlpha)
	///
	/// Categories: Reduction, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that specifies the subregion of the image that you want to process.
	///   - active: should this filter be applied
	/// - Returns: a single-pixel image that contains the color vector with the minimum alpha value for the region of interest, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func areaMinimumAlpha(extent: CGRect, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.areaMinimumAlpha() // CIAreaMinimumAlpha
		filter.inputImage = self
		filter.extent = extent
		return filter.outputImage ?? CIImage.empty()
	}

	/// Bars Swipe Transition
	///
	/// Transitions from one image to another by swiping rectangular portions of the foreground image to disclose the target image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIBarsSwipeTransition)
	///
	/// Categories: Transition, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - targetImage: The target image for a transition.
	///   - angle: The angle in radians of the bars.
	///   - width: The width of each bar. (2...)
	///   - barOffset: The offset of one bar with respect to another. (1...)
	///   - time: The parametric time of the transition. This value drives the transition from start (at time 0) to end (at time 1). (0...1)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func barsSwipeTransition(targetImage: CIImage,
							 angle: Float = .pi,
							 width: Float,
							 barOffset: Float = 10,
							 time: Float) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.barsSwipeTransition() // CIBarsSwipeTransition
		filter.inputImage = self
		filter.targetImage = targetImage
		filter.angle = angle
		filter.width = width
		filter.barOffset = barOffset
		filter.time = time
		return filter.outputImage ?? CIImage.empty()
	}

	/// Bicubic Scale Transform
	///
	/// Produces a high-quality, scaled version of a source image. The parameters of B and C for this filter determine the sharpness or softness of the resampling. The most commonly used B and C values are 0.0 and 0.75, respectively.
	///
	/// ⚠️ No Apple Documentation available for 'CIBicubicScaleTransform'
	///
	/// Categories: Geometry Adjustment, Video, Still Image, Non-Square Pixels, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - scale: The scaling factor to use on the image. Values less than 1.0 scale down the images. Values greater than 1.0 scale up the image. (0...)
	///   - aspectRatio: The additional horizontal scaling factor to use on the image. (0...)
	///   - parameterB: Specifies the value of B to use for the cubic resampling function. (0...1)
	///   - parameterC: Specifies the value of C to use for the cubic resampling function. (0...1)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func bicubicScaleTransform(scale: Float = 1,
							   aspectRatio: Float = 1,
							   parameterB: Float = 0,
							   parameterC: Float = 0.75) -> CIImage {
		guard scale != 1 || aspectRatio != 1 else { return self }

		let filter = CIFilter.bicubicScaleTransform() // CIBicubicScaleTransform
		filter.inputImage = self
		filter.scale = scale
		filter.aspectRatio = aspectRatio
		filter.parameterB = parameterB
		filter.parameterC = parameterC
		return filter.outputImage ?? CIImage.empty()
	}

	/// Blend With Alpha Mask
	///
	/// Uses values from a mask image to interpolate between an image and the background. When a mask alpha value is 0.0, the result is the background. When the mask alpha value is 1.0, the result is the image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIBlendWithAlphaMask)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	///   - maskImage: A masking image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func blendWithAlphaMask(backgroundImage: CIImage?, maskImage: CIImage) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.blendWithAlphaMask() // CIBlendWithAlphaMask
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		filter.maskImage = maskImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Blend With Blue Mask
	///
	/// Uses values from a mask image to interpolate between an image and the background. When a mask blue value is 0.0, the result is the background. When the mask blue value is 1.0, the result is the image.
	///
	/// ⚠️ No Apple Documentation available for 'CIBlendWithBlueMask'
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	///   - maskImage: A masking image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func blendWithBlueMask(backgroundImage: CIImage?, maskImage: CIImage) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.blendWithBlueMask() // CIBlendWithBlueMask
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		filter.maskImage = maskImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Blend With Mask
	///
	/// Uses values from a grayscale mask to interpolate between an image and the background. When a mask green value is 0.0, the result is the background. When the mask green value is 1.0, the result is the image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIBlendWithMask)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	///   - maskImage: A grayscale mask. When a mask value is 0.0, the result is the background. When the mask value is 1.0, the result is the image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func blendWithMask(backgroundImage: CIImage?, maskImage: CIImage) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.blendWithMask() // CIBlendWithMask
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		filter.maskImage = maskImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Blend With Red Mask
	///
	/// Uses values from a mask image to interpolate between an image and the background. When a mask red value is 0.0, the result is the background. When the mask red value is 1.0, the result is the image.
	///
	/// ⚠️ No Apple Documentation available for 'CIBlendWithRedMask'
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	///   - maskImage: A masking image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func blendWithRedMask(backgroundImage: CIImage?, maskImage: CIImage) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.blendWithRedMask() // CIBlendWithRedMask
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		filter.maskImage = maskImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Bloom
	///
	/// Softens edges and applies a pleasant glow to an image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIBloom)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - radius: The radius determines how many pixels are used to create the effect. The larger the radius, the greater the effect. (0...)
	///   - intensity: The intensity of the effect. A value of 0.0 is no effect. A value of 1.0 is the maximum effect. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func bloom(radius: Float, intensity: Float = 0.5) -> CIImage {
		guard radius != 0 || intensity != 0 else { return self }

		let filter = CIFilter.bloom() // CIBloom
		filter.inputImage = self
		filter.radius = radius
		filter.intensity = intensity
		return filter.outputImage ?? CIImage.empty()
	}

	/// Bokeh Blur
	///
	/// Smooths an image using a disc-shaped convolution kernel.
	///
	/// ⚠️ No Apple Documentation available for 'CIBokehBlur'
	///
	/// Categories: Blur, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - radius: The radius determines how many pixels are used to create the blur. The larger the radius, the blurrier the result. (0...500)
	///   - ringAmount: The amount of extra emphasis at the ring of the bokeh. (0...1)
	///   - ringSize: The size of extra emphasis at the ring of the bokeh. (0...0.2)
	///   - softness: The softness of the bokeh effect. (0...10)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func bokehBlur(radius: Float,
				   ringAmount: Float = 0,
				   ringSize: Float = 0.1,
				   softness: Float = 1,
				   active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.bokehBlur() // CIBokehBlur
		filter.inputImage = self
		filter.radius = radius
		filter.ringAmount = ringAmount
		filter.ringSize = ringSize
		filter.softness = softness
		return filter.outputImage ?? CIImage.empty()
	}

	/// Box Blur
	///
	/// Smooths or sharpens an image using a box-shaped convolution kernel.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIBoxBlur)
	///
	/// Categories: Blur, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - radius: The radius determines how many pixels are used to create the blur. The larger the radius, the blurrier the result. (1...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func boxBlur(radius: Float, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.boxBlur() // CIBoxBlur
		filter.inputImage = self
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Bump Distortion
	///
	/// Creates a concave or convex bump that originates at a specified point in the image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIBumpDistortion)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - radius: The radius determines how many pixels are used to create the distortion. The larger the radius, the wider the extent of the distortion. (0...)
	///   - scale: The scale of the effect determines the curvature of the bump. A value of 0.0 has no effect. Positive values create an outward bump; negative values create an inward bump.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 14, macOS 11.0, *)
	func bumpDistortion(center: CGPoint, radius: Float, scale: Float = 0.5) -> CIImage {
		guard scale != 0 else { return self }

		let filter = CIFilter.bumpDistortion() // CIBumpDistortion
		filter.inputImage = self
		filter.center = center
		filter.radius = radius
		filter.scale = scale
		return filter.outputImage ?? CIImage.empty()
	}

	/// Bump Distortion Linear
	///
	/// Creates a concave or convex distortion that originates from a line in the image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIBumpDistortionLinear)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - radius: The radius determines how many pixels are used to create the distortion. The larger the radius, the wider the extent of the distortion. (0...)
	///   - angle: The angle in radians of the line around which the distortion occurs.
	///   - scale: The scale of the effect. (-1...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 14, macOS 11.0, *)
	func bumpDistortionLinear(center: CGPoint, radius: Float, angle: Float = 0, scale: Float = 0.5) -> CIImage {
		guard radius != 0 || angle != 0 || scale != 1 else { return self }

		let filter = CIFilter.bumpDistortionLinear() // CIBumpDistortionLinear
		filter.inputImage = self
		filter.center = center
		filter.radius = radius
		filter.angle = angle
		filter.scale = scale
		return filter.outputImage ?? CIImage.empty()
	}

	/// CMYK Halftone
	///
	/// Creates a color, halftoned rendition of the source image, using cyan, magenta, yellow, and black inks over a white page.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CICMYKHalftone)
	///
	/// Categories: Halftone Effect, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - width: The distance between dots in the pattern. (-2...)
	///   - angle: The angle in radians of the pattern.
	///   - sharpness: The sharpness of the pattern. The larger the value, the sharper the pattern. (0...)
	///   - grayComponentReplacement: The gray component replacement value. The value can vary from 0.0 (none) to 1.0. (0...)
	///   - underColorRemoval: The under color removal value. The value can vary from 0.0 to 1.0.  (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func cmykHalftone(center: CGPoint,
					  width: Float,
					  angle: Float = 0,
					  sharpness: Float,
					  grayComponentReplacement: Float = 1,
					  underColorRemoval: Float = 0.5) -> CIImage {
		guard angle != 0 || grayComponentReplacement != 1 || underColorRemoval != 0.5 else { return self }

		let filter = CIFilter.cmykHalftone() // CICMYKHalftone
		filter.inputImage = self
		filter.center = center
		filter.width = width
		filter.angle = angle
		filter.sharpness = sharpness
		filter.grayComponentReplacement = grayComponentReplacement
		filter.underColorRemoval = underColorRemoval
		return filter.outputImage ?? CIImage.empty()
	}

	/// Lens Correction for AVC
	///
	/// Geometrically distorts an image by altering the magnification based on the radial distance from the optical center to the farthest radius.
	///
	/// ⚠️ No Apple Documentation available for 'CICameraCalibrationLensCorrection'
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - avcameracalibrationdata: AVCameraCalibrationData for the correction. Will be set from the input image if available and can be overridden here.
	///   - useInverseLookupTable: Boolean value used to select the Look Up Table from the AVCameraCalibrationData.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func cameraCalibrationLensCorrection(avcameracalibrationdata: AVCameraCalibrationData,
										 useInverseLookupTable: Bool = false,
										 active: Bool = true) -> CIImage {
		guard active else { return self }

		// Filter not included in CoreImage.CIFilterBuiltins; using dictionary-based method.
		guard let filter = CIFilter(name: "CICameraCalibrationLensCorrection", parameters: [

			"inputAVCameraCalibrationData": avcameracalibrationdata,
			"inputUseInverseLookUpTable": useInverseLookupTable,
		]) else { return self }
		return filter.outputImage ?? CIImage.empty()
	}

	/// Canny Edge Detector
	///
	/// Applies the Canny Edge Detection algorithm to an image.
	///
	/// ⚠️ No Apple Documentation available for 'CICannyEdgeDetector'
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - gaussianSigma: The gaussian sigma of blur to apply to the image to reduce high-frequency noise. (0...)
	///   - perceptual: Specifies whether the edge thresholds should be computed in a perceptual color space.
	///   - thresholdHigh: The threshold that determines if gradient magnitude is a strong edge. (0...)
	///   - thresholdLow: The threshold that determines if gradient magnitude is a weak edge. (0...)
	///   - hysteresisPasses: The number of hysteresis passes to apply to promote weak edge pixels. (0...20)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 17, macOS 14.0, *)
	func cannyEdgeDetector(gaussianSigma: Float = 1.6,
						   perceptual: Bool = false,
						   thresholdHigh: Float = 0.05,
						   thresholdLow: Float = 0.02,
						   hysteresisPasses: Int,
						   active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.cannyEdgeDetector() // CICannyEdgeDetector
		filter.inputImage = self
		filter.gaussianSigma = gaussianSigma
		filter.perceptual = perceptual
		filter.thresholdHigh = thresholdHigh
		filter.thresholdLow = thresholdLow
		filter.hysteresisPasses = hysteresisPasses
		return filter.outputImage ?? CIImage.empty()
	}

	/// Circle Splash Distortion
	///
	/// Distorts the pixels starting at the circumference of a circle and emanating outward.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CICircleSplashDistortion)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - radius: The radius determines how many pixels are used to create the distortion. The larger the radius, the wider the extent of the distortion. (0...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func circleSplashDistortion(center: CGPoint, radius: Float, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.circleSplashDistortion() // CICircleSplashDistortion
		filter.inputImage = self
		filter.center = center
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Circular Screen
	///
	/// Simulates a circular-shaped halftone screen.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CICircularScreen)
	///
	/// Categories: Halftone Effect, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - width: The distance between each circle in the pattern. (1...)
	///   - sharpness: The sharpness of the circles. The larger the value, the sharper the circles. (0...1)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func circularScreen(center: CGPoint, width: Float, sharpness: Float = 0.7, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.circularScreen() // CICircularScreen
		filter.inputImage = self
		filter.center = center
		filter.width = width
		filter.sharpness = sharpness
		return filter.outputImage ?? CIImage.empty()
	}

	/// Circular Wrap Distortion
	///
	/// Wraps an image around a transparent circle. The distortion of the image increases with the distance from the center of the circle.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CICircularWrap)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - radius: The radius determines how many pixels are used to create the distortion. The larger the radius, the wider the extent of the distortion. (0...)
	///   - angle: The angle in radians of the effect.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 14, macOS 11.0, *)
	func circularWrap(center: CGPoint, radius: Float, angle: Float = 0) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.circularWrap() // CICircularWrap
		filter.inputImage = self
		filter.center = center
		filter.radius = radius
		filter.angle = angle
		return filter.outputImage ?? CIImage.empty()
	}

	// NOTE: CIClamp already has a CIImage method: func clamped(to: CGRect) -> CIImage


	/// Color Absolute Difference
	///
	/// Produces an image that is the absolute value of the color difference between two images. The alpha channel of the result will be the product of the two image alpha channels.
	///
	/// ⚠️ No Apple Documentation available for 'CIColorAbsoluteDifference'
	///
	/// Categories: Color Adjustment, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - inputImage2: The second input image for differencing.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func colorAbsoluteDifference(inputImage2: CIImage, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.colorAbsoluteDifference() // CIColorAbsoluteDifference
		filter.inputImage = self
		filter.inputImage2 = inputImage2
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Blend Mode
	///
	/// Uses the luminance values of the background with the hue and saturation values of the source image. This mode preserves the gray levels in the image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func colorBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.colorBlendMode() // CIColorBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Burn Blend Mode
	///
	/// Darkens the background image samples to reflect the source image samples. Source image sample values that specify white do not produce a change.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorBurnBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func colorBurnBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.colorBurnBlendMode() // CIColorBurnBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Clamp
	///
	/// Modifies color values to keep them within a specified range.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorClamp)
	///
	/// Categories: Color Adjustment, Video, Interlaced, Non-Square Pixels, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - minComponents: Lower clamping values.
	///   - maxComponents: Higher clamping values.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func colorClamp(minComponents: CIVector, maxComponents: CIVector, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.colorClamp() // CIColorClamp
		filter.inputImage = self
		filter.minComponents = minComponents
		filter.maxComponents = maxComponents
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Controls
	///
	/// Adjusts saturation, brightness, and contrast values.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorControls)
	///
	/// Categories: Color Adjustment, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - saturation: The amount of saturation to apply. The larger the value, the more saturated the result. (0...)
	///   - brightness: The amount of brightness to apply. The larger the value, the brighter the result. (-1...)
	///   - contrast: The amount of contrast to apply. The larger the value, the more contrast in the resulting image. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func colorControls(saturation: Float = 1, brightness: Float = 0, contrast: Float = 1) -> CIImage {
		guard saturation != 1 || brightness != 0 || contrast != 1 else { return self }

		let filter = CIFilter.colorControls() // CIColorControls
		filter.inputImage = self
		filter.saturation = saturation
		filter.brightness = brightness
		filter.contrast = contrast
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Cross Polynomial
	///
	/// Modifies the pixel values in an image by applying a set of polynomial cross-products.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorCrossPolynomial)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - redCoefficients: Polynomial coefficients for red channel.
	///   - greenCoefficients: Polynomial coefficients for green channel.
	///   - blueCoefficients: Polynomial coefficients for blue channel.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func colorCrossPolynomial(redCoefficients: CIVector,
							  greenCoefficients: CIVector,
							  blueCoefficients: CIVector,
							  active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.colorCrossPolynomial() // CIColorCrossPolynomial
		filter.inputImage = self
		filter.redCoefficients = redCoefficients
		filter.greenCoefficients = greenCoefficients
		filter.blueCoefficients = blueCoefficients
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Cube
	///
	/// Uses a three-dimensional color table to transform the source image pixels.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorCube)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - cubeDimension: The dimension of the color cube.(2...64 iOS; 2...128 macOS)
	///   - cubeData: Data containing a 3-dimensional color table of floating-point premultiplied RGBA values. The cells are organized in a standard ordering. The columns and rows of the data are indexed by red and green, respectively. Each data plane is followed by the next higher plane in the data, with planes indexed by blue.
	///   - extrapolate: If true, then the color cube will be extrapolated if the input image contains RGB component values outside the range 0.0 to 1.0.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 16, macOS 13.0, *)
	func colorCube(cubeDimension: Int, cubeData: Data, extrapolate: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.colorCube() // CIColorCube
		filter.inputImage = self
		filter.cubeDimension = Float(cubeDimension)
		filter.cubeData = cubeData
		filter.extrapolate = extrapolate
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Cube with ColorSpace
	///
	/// Uses a three-dimensional color table to transform the source image pixels and maps the result to a specified color space.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorCubeWithColorSpace)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - cubeDimension: The dimension of the color cube.(2...64 iOS; 2...128 macOS)
	///   - cubeData: Data containing a 3-dimensional color table of floating-point premultiplied RGBA values. The cells are organized in a standard ordering. The columns and rows of the data are indexed by red and green, respectively. Each data plane is followed by the next higher plane in the data, with planes indexed by blue.
	///   - extrapolate: If true, then the color cube will be extrapolated if the input image contains RGB component values outside the range 0.0 to 1.0.
	///   - colorSpace: The CGColorSpace that defines the RGB values in the color table.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 16, macOS 13.0, *)
	func colorCubeWithColorSpace(cubeDimension: Int,
								 cubeData: Data,
								 extrapolate: Bool,
								 colorSpace: CGColorSpace,
								 active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.colorCubeWithColorSpace() // CIColorCubeWithColorSpace
		filter.inputImage = self
		filter.cubeDimension = Float(cubeDimension)
		filter.cubeData = cubeData
		filter.extrapolate = extrapolate
		filter.colorSpace = colorSpace
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Cubes Mixed With Mask
	///
	/// Uses two three-dimensional color tables in a specified colorspace to transform the source image pixels. The mask image is used as an interpolant to mix the output of the two cubes.
	///
	/// ⚠️ No Apple Documentation available for 'CIColorCubesMixedWithMask'
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - maskImage: A masking image.
	///   - cubeDimension: The dimension of the color cubes.(2...64 iOS; 2...128 macOS)
	///   - cube0Data: Data containing a 3-dimensional color table of floating-point premultiplied RGBA values. The cells are organized in a standard ordering. The columns and rows of the data are indexed by red and green, respectively. Each data plane is followed by the next higher plane in the data, with planes indexed by blue.
	///   - cube1Data: Data containing a 3-dimensional color table of floating-point premultiplied RGBA values. The cells are organized in a standard ordering. The columns and rows of the data are indexed by red and green, respectively. Each data plane is followed by the next higher plane in the data, with planes indexed by blue.
	///   - colorSpace: The CGColorSpace that defines the RGB values in the color table.
	///   - extrapolate: If true, then the color cube will be extrapolated if the input image contains RGB component values outside the range 0 to 1.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 16, macOS 13.0, *)
	func colorCubesMixedWithMask(maskImage: CIImage,
								 cubeDimension: Int,
								 cube0Data: Data,
								 cube1Data: Data,
								 colorSpace: CGColorSpace,
								 extrapolate: Bool = false,
								 active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.colorCubesMixedWithMask() // CIColorCubesMixedWithMask
		filter.inputImage = self
		filter.maskImage = maskImage
		filter.cubeDimension = Float(cubeDimension)
		filter.cube0Data = cube0Data
		filter.cube1Data = cube1Data
		filter.colorSpace = colorSpace
		filter.extrapolate = extrapolate
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Curves
	///
	/// Uses a three-channel one-dimensional color table to transform the source image pixels.
	///
	/// ⚠️ No Apple Documentation available for 'CIColorCurves'
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - curvesData: Data containing a color table of floating-point RGB values.
	///   - curvesDomain: A two-element vector that defines the minimum and maximum RGB component values that are used to look up result values from the color table.
	///   - colorSpace: The CGColorSpace that defines the RGB values in the color table.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func colorCurves(curvesData: Data, curvesDomain: CIVector, colorSpace: CGColorSpace, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.colorCurves() // CIColorCurves
		filter.inputImage = self
		filter.curvesData = curvesData
		filter.curvesDomain = curvesDomain
		filter.colorSpace = colorSpace
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Dodge Blend Mode
	///
	/// Brightens the background image samples to reflect the source image samples. Source image sample values that specify black do not produce a change.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorDodgeBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func colorDodgeBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.colorDodgeBlendMode() // CIColorDodgeBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Invert
	///
	/// Inverts the colors in an image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorInvert)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func colorInvert(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.colorInvert() // CIColorInvert
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Map
	///
	/// Performs a nonlinear transformation of source color values using mapping values provided in a table.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorMap)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - gradientImage: The image data from this image transforms the source image values.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func colorMap(gradientImage: CIImage, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.colorMap() // CIColorMap
		filter.inputImage = self
		filter.gradientImage = gradientImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Matrix
	///
	/// Multiplies source color values and adds a bias factor to each color component.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorMatrix)
	///
	/// Categories: Color Adjustment, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - rVector: The amount of red to multiply the source color values by.
	///   - gVector: The amount of green to multiply the source color values by.
	///   - bVector: The amount of blue to multiply the source color values by.
	///   - aVector: The amount of alpha to multiply the source color values by.
	///   - biasVector: A vector that’s added to each color component.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func colorMatrix(rVector: CIVector,
					 gVector: CIVector,
					 bVector: CIVector,
					 aVector: CIVector,
					 biasVector: CIVector,
					 active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.colorMatrix() // CIColorMatrix
		filter.inputImage = self
		filter.rVector = rVector
		filter.gVector = gVector
		filter.bVector = bVector
		filter.aVector = aVector
		filter.biasVector = biasVector
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Monochrome
	///
	/// Remaps colors so they fall within shades of a single color.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorMonochrome)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - color: The monochrome color to apply to the image.
	///   - intensity: The intensity of the monochrome effect. A value of 1.0 creates a monochrome image using the supplied color. A value of 0.0 has no effect on the image. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func colorMonochrome(color: CIColor, intensity: Float = 1) -> CIImage {
		guard intensity != 0 else { return self }

		let filter = CIFilter.colorMonochrome() // CIColorMonochrome
		filter.inputImage = self
		filter.color = color
		filter.intensity = intensity
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Polynomial
	///
	/// Modifies the pixel values in an image by applying a set of cubic polynomials.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorPolynomial)
	///
	/// Categories: Color Adjustment, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - redCoefficients: Polynomial coefficients for red channel.
	///   - greenCoefficients: Polynomial coefficients for green channel.
	///   - blueCoefficients: Polynomial coefficients for blue channel.
	///   - alphaCoefficients: Polynomial coefficients for alpha channel.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func colorPolynomial(redCoefficients: CIVector,
						 greenCoefficients: CIVector,
						 blueCoefficients: CIVector,
						 alphaCoefficients: CIVector,
						 active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.colorPolynomial() // CIColorPolynomial
		filter.inputImage = self
		filter.redCoefficients = redCoefficients
		filter.greenCoefficients = greenCoefficients
		filter.blueCoefficients = blueCoefficients
		filter.alphaCoefficients = alphaCoefficients
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Posterize
	///
	/// Remaps red, green, and blue color components to the number of brightness values you specify for each color component. This filter flattens colors to achieve a look similar to that of a silk-screened poster.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColorPosterize)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - levels: The number of brightness levels to use for each color component. Lower values result in a more extreme poster effect. (1...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func colorPosterize(levels: Float = 6) -> CIImage {
		guard levels != 300 else { return self }

		let filter = CIFilter.colorPosterize() // CIColorPosterize
		filter.inputImage = self
		filter.levels = levels
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Threshold
	///
	/// Produces a binarized image from an image and a threshold value. The red, green and blue channels of the resulting image will be one if its value is greater than the threshold and zero otherwise.
	///
	/// ⚠️ No Apple Documentation available for 'CIColorThreshold'
	///
	/// Categories: Color Adjustment, Video, Interlaced, Non-Square Pixels, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - threshold: The threshold value that governs if the RGB channels of the resulting image will be zero or one.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func colorThreshold(threshold: Float = 0.5, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.colorThreshold() // CIColorThreshold
		filter.inputImage = self
		filter.threshold = threshold
		return filter.outputImage ?? CIImage.empty()
	}

	/// Color Threshold Otsu
	///
	/// Produces a binarized image from an image with finite extent. The threshold is calculated from the image histogram using Otsu’s method. The red, green and blue channels of the resulting image will be one if its value is greater than the threshold and zero otherwise.
	///
	/// ⚠️ No Apple Documentation available for 'CIColorThresholdOtsu'
	///
	/// Categories: Color Adjustment, Video, Interlaced, Non-Square Pixels, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func colorThresholdOtsu(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.colorThresholdOtsu() // CIColorThresholdOtsu
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Column Average
	///
	/// Calculates the average color for each column of the specified area in an image, returning the result in a 1D image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIColumnAverage)
	///
	/// Categories: Reduction, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that specifies the subregion of the image that you want to process.
	///   - active: should this filter be applied
	/// - Returns: a 1-pixel high image that contains the average color for each scan column, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func columnAverage(extent: CGRect, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.columnAverage() // CIColumnAverage
		filter.inputImage = self
		filter.extent = extent
		return filter.outputImage ?? CIImage.empty()
	}

	/// Comic Effect
	///
	/// Simulates a comic book drawing by outlining edges and applying a color halftone effect.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIComicEffect)
	///
	/// Categories: Stylize, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func comicEffect(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.comicEffect() // CIComicEffect
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Convert Lab to RGB
	///
	/// Converts an image from La*b* color space to the Core Image RGB working space.
	///
	/// ⚠️ No Apple Documentation available for 'CIConvertLabToRGB'
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - normalize: If normalize is false then the L channel is in the range 0 to 100 and the a*b* channels are in the range -128 to 128. If normalize is true then the La*b* channels are in the range 0 to 1.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 16, macOS 13.0, *)
	func convertLabToRGB(normalize: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.convertLabToRGB() // CIConvertLabToRGB
		filter.inputImage = self
		filter.normalize = normalize
		return filter.outputImage ?? CIImage.empty()
	}

	/// Convert RGB to Lab
	///
	/// Converts an image from the Core Image RGB working space to La*b* color space.
	///
	/// ⚠️ No Apple Documentation available for 'CIConvertRGBtoLab'
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - normalize: If normalize is false then the L channel is in the range 0 to 100 and the a*b* channels are in the range -128 to 128. If normalize is true then the La*b* channels are in the range 0 to 1.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 16, macOS 13.0, *)
	func convertRGBtoLab(normalize: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.convertRGBtoLab() // CIConvertRGBtoLab
		filter.inputImage = self
		filter.normalize = normalize
		return filter.outputImage ?? CIImage.empty()
	}

	/// 3 by 3 Convolution
	///
	/// Modifies pixel values by performing a 3x3 matrix convolution.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIConvolution3X3)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - weights: A vector containing the 9 weights of the convolution kernel.
	///   - bias: A value that is added to the RGBA components of the output pixel.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func convolution3X3(weights: CIVector, bias: Float = 0) -> CIImage {
		guard bias != 0 else { return self }

		let filter = CIFilter.convolution3X3() // CIConvolution3X3
		filter.inputImage = self
		filter.weights = weights
		filter.bias = bias
		return filter.outputImage ?? CIImage.empty()
	}

	/// 5 by 5 Convolution
	///
	/// Modifies pixel values by performing a 5x5 matrix convolution.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIConvolution5X5)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - weights: A vector containing the 25 weights of the convolution kernel.
	///   - bias: A value that is added to the RGBA components of the output pixel.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func convolution5X5(weights: CIVector, bias: Float = 0) -> CIImage {
		guard bias != 0 else { return self }

		let filter = CIFilter.convolution5X5() // CIConvolution5X5
		filter.inputImage = self
		filter.weights = weights
		filter.bias = bias
		return filter.outputImage ?? CIImage.empty()
	}

	/// 7 by 7 Convolution
	///
	/// Modifies pixel values by performing a 7x7 matrix convolution.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIConvolution7X7)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - weights: A vector containing the 49 weights of the convolution kernel.
	///   - bias: A value that is added to the RGBA components of the output pixel.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func convolution7X7(weights: CIVector, bias: Float = 0) -> CIImage {
		guard bias != 0 else { return self }

		let filter = CIFilter.convolution7X7() // CIConvolution7X7
		filter.inputImage = self
		filter.weights = weights
		filter.bias = bias
		return filter.outputImage ?? CIImage.empty()
	}

	/// Horizontal 9 Convolution
	///
	/// Modifies pixel values by performing a 9-element horizontal convolution.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIConvolution9Horizontal)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - weights: A vector containing the 9 weights of the convolution kernel.
	///   - bias: A value that is added to the RGBA components of the output pixel.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func convolution9Horizontal(weights: CIVector, bias: Float = 0) -> CIImage {
		guard bias != 0 else { return self }

		let filter = CIFilter.convolution9Horizontal() // CIConvolution9Horizontal
		filter.inputImage = self
		filter.weights = weights
		filter.bias = bias
		return filter.outputImage ?? CIImage.empty()
	}

	/// Vertical 9 Convolution
	///
	/// Modifies pixel values by performing a 9-element vertical convolution.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIConvolution9Vertical)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - weights: A vector containing the 9 weights of the convolution kernel.
	///   - bias: A value that is added to the RGBA components of the output pixel.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func convolution9Vertical(weights: CIVector, bias: Float = 0) -> CIImage {
		guard bias != 0 else { return self }

		let filter = CIFilter.convolution9Vertical() // CIConvolution9Vertical
		filter.inputImage = self
		filter.weights = weights
		filter.bias = bias
		return filter.outputImage ?? CIImage.empty()
	}

	/// 3 by 3 RGB Convolution
	///
	/// Convolution of RGB channels with 3 by 3 matrix.
	///
	/// ⚠️ No Apple Documentation available for 'CIConvolutionRGB3X3'
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - weights: A vector containing the 9 weights of the convolution kernel.
	///   - bias: A value that is added to the RGB components of the output pixel.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 15, macOS 12.0, *)
	func convolutionRGB3X3(weights: CIVector, bias: Float = 0) -> CIImage {
		guard bias != 0 else { return self }

		let filter = CIFilter.convolutionRGB3X3() // CIConvolutionRGB3X3
		filter.inputImage = self
		filter.weights = weights
		filter.bias = bias
		return filter.outputImage ?? CIImage.empty()
	}

	/// 5 by 5 RGB Convolution
	///
	/// Convolution of RGB channels with 5 by 5 matrix.
	///
	/// ⚠️ No Apple Documentation available for 'CIConvolutionRGB5X5'
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - weights: A vector containing the 25 weights of the convolution kernel.
	///   - bias: A value that is added to the RGB components of the output pixel.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 15, macOS 12.0, *)
	func convolutionRGB5X5(weights: CIVector, bias: Float = 0) -> CIImage {
		guard bias != 0 else { return self }

		let filter = CIFilter.convolutionRGB5X5() // CIConvolutionRGB5X5
		filter.inputImage = self
		filter.weights = weights
		filter.bias = bias
		return filter.outputImage ?? CIImage.empty()
	}

	/// 7 by 7 RGB Convolution
	///
	/// Convolution of RGB channels with 7 by 7 matrix.
	///
	/// ⚠️ No Apple Documentation available for 'CIConvolutionRGB7X7'
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - weights: A vector containing the 49 weights of the convolution kernel.
	///   - bias: A value that is added to the RGB components of the output pixel.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 15, macOS 12.0, *)
	func convolutionRGB7X7(weights: CIVector, bias: Float = 0) -> CIImage {
		guard bias != 0 else { return self }

		let filter = CIFilter.convolutionRGB7X7() // CIConvolutionRGB7X7
		filter.inputImage = self
		filter.weights = weights
		filter.bias = bias
		return filter.outputImage ?? CIImage.empty()
	}

	/// Horizontal 9 RGB Convolution
	///
	/// Horizontal Convolution of RGB channels with 9 values.
	///
	/// ⚠️ No Apple Documentation available for 'CIConvolutionRGB9Horizontal'
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - weights: A vector containing the 9 weights of the convolution kernel.
	///   - bias: A value that is added to the RGB components of the output pixel.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 15, macOS 12.0, *)
	func convolutionRGB9Horizontal(weights: CIVector, bias: Float = 0) -> CIImage {
		guard bias != 0 else { return self }

		let filter = CIFilter.convolutionRGB9Horizontal() // CIConvolutionRGB9Horizontal
		filter.inputImage = self
		filter.weights = weights
		filter.bias = bias
		return filter.outputImage ?? CIImage.empty()
	}

	/// Vertical 9 RGB Convolution
	///
	/// Vertical Convolution of RGB channels with 9 values.
	///
	/// ⚠️ No Apple Documentation available for 'CIConvolutionRGB9Vertical'
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - weights: A vector containing the 9 weights of the convolution kernel.
	///   - bias: A value that is added to the RGB components of the output pixel.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 15, macOS 12.0, *)
	func convolutionRGB9Vertical(weights: CIVector, bias: Float = 0) -> CIImage {
		guard bias != 0 else { return self }

		let filter = CIFilter.convolutionRGB9Vertical() // CIConvolutionRGB9Vertical
		filter.inputImage = self
		filter.weights = weights
		filter.bias = bias
		return filter.outputImage ?? CIImage.empty()
	}

	/// Copy Machine
	///
	/// Transitions from one image to another by simulating the effect of a copy machine.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CICopyMachineTransition)
	///
	/// Categories: Transition, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - targetImage: The target image for a transition.
	///   - extent: A rectangle that defines the extent of the effect.
	///   - color: The color of the copier light.
	///   - time: The parametric time of the transition. This value drives the transition from start (at time 0) to end (at time 1). (0...1)
	///   - angle: The angle in radians of the copier light. (0...)
	///   - width: The width of the copier light.  (0.1...)
	///   - opacity: The opacity of the copier light. A value of 0.0 is transparent. A value of 1.0 is opaque. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func copyMachineTransition(targetImage: CIImage,
							   extent: CGRect,
							   color: CIColor,
							   time: Float,
							   angle: Float = 0,
							   width: Float,
							   opacity: Float = 1.3) -> CIImage {
		guard angle != 0 || opacity != 1.3 else { return self }

		let filter = CIFilter.copyMachineTransition() // CICopyMachineTransition
		filter.inputImage = self
		filter.targetImage = targetImage
		filter.extent = extent
		filter.color = color
		filter.time = time
		filter.angle = angle
		filter.width = width
		filter.opacity = opacity
		return filter.outputImage ?? CIImage.empty()
	}

	/// CoreML Model Filter
	///
	/// Generates output image by applying input CoreML model to the input image.
	///
	/// ⚠️ No Apple Documentation available for 'CICoreMLModelFilter'
	/// [WWDC Video](https://developer.apple.com/videos/play/wwdc2018-719/?time=2378)
	///
	/// Categories: Still Image, Built-In, Stylize
	///
	///
	/// - Parameters:
	///   - model: The CoreML model to be used for applying effect on the image.
	///   - headIndex: A number to specify which output of a multi-head CoreML model should be used for applying effect on the image. (0...10)
	///   - softmaxNormalization: A boolean value to specify that Softmax normalization should be applied to the output of the model.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func coreMLModel(model: MLModel, headIndex: Int, softmaxNormalization: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.coreMLModel() // CICoreMLModelFilter
		filter.inputImage = self
		filter.model = model
		filter.headIndex = Float(headIndex)
		filter.softmaxNormalization = softmaxNormalization
		return filter.outputImage ?? CIImage.empty()
	}

	// NOTE: CICrop already has a CIImage method: func cropped(to: CGRect) -> CIImage


	/// Crystallize
	///
	/// Creates polygon-shaped color blocks by aggregating source pixel-color values.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CICrystallize)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - radius: The radius determines how many pixels are used to create the effect. The larger the radius, the larger the resulting crystals. (1...)
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func crystallize(radius: Float, center: CGPoint, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.crystallize() // CICrystallize
		filter.inputImage = self
		filter.radius = radius
		filter.center = center
		return filter.outputImage ?? CIImage.empty()
	}

	/// Darken Blend Mode
	///
	/// Creates composite image samples by choosing the darker samples (from either the source image or the background). The result is that the background image samples are replaced by any source image samples that are darker. Otherwise, the background image samples are left unchanged.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIDarkenBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func darkenBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.darkenBlendMode() // CIDarkenBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Depth Blur Effect
	///
	/// Applies a variable radius disc blur to an image where areas in the background are softened more than those in the foreground.
	///
	/// ⚠️ No Apple Documentation available for 'CIDepthBlurEffect'
	/// [WWDC Video](https://devstreaming-cdn.apple.com/videos/wwdc/2017/508wdyl5rm2jy9z8/508/508_hd_image_editing_with_depth.mp4)
	/// [WWDC Slides](https://devstreaming-cdn.apple.com/videos/wwdc/2017/508wdyl5rm2jy9z8/508/508_image_editing_with_depth.pdf)
	///
	/// Categories: Blur, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - disparityImage: Grayscale image indicating depth; lighter is nearer.
	///   - matteImage: A matting image.
	///   - hairImage: A segmentation matte image that corresponds to people’s hair.
	///   - glassesImage: A segmentation matte image that corresponds to people’s glasses.
	///   - gainMap: UNKNOWN
	///   - aperture: Simulated lens aperature to adjust blur for unfocused elements (0...22)
	///   - leftEyePositions: Vector of up to 4 x,y positions indicating where peoples' left eyes are
	///   - rightEyePositions: Vector of up to 4 x,y positions indicating where peoples' right eyes are
	///   - chinPositions: Vector of up to 4 x,y positions indicating where peoples' chins are
	///   - nosePositions: Vector of up to 4 x,y positions indicating where peoples' noses are
	///   - focusRectangle: Part of the rectangle to make sure to put into focus
	///   - lumaNoiseScale: UNKNOWN (0...0.1)
	///   - scaleFactor: Integrated downsampling (rather than doing it later) since this is computationally expensive
	///   - calibrationData: UNKNOWN
	///   - auxDataMetadata: UNKNOWN
	///   - shape: UNKNOWN
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func depthBlurEffect(disparityImage: CIImage,
						 matteImage: CIImage,
						 hairImage: CIImage,
						 glassesImage: CIImage,
						 gainMap: CIImage,
						 aperture: Float = 0,
						 leftEyePositions: CIVector = .init(x: -1, y: -1),
						 rightEyePositions: CIVector = .init(x: -1, y: -1),
						 chinPositions: CIVector = .init(x: -1, y: -1),
						 nosePositions: CIVector = .init(x: -1, y: -1),
						 focusRectangle: CIVector,
						 lumaNoiseScale: Float = 0,
						 scaleFactor: Float = 1,
						 calibrationData: AVCameraCalibrationData,
						 auxDataMetadata: CGImageMetadata,
						 shape: String,
						 active: Bool = true) -> CIImage {
		guard active else { return self }

		// Filter not included in CoreImage.CIFilterBuiltins; using dictionary-based method.
		guard let filter = CIFilter(name: "CIDepthBlurEffect", parameters: [

			"inputDisparityImage": disparityImage,
			"inputMatteImage": matteImage,
			"inputHairImage": hairImage,
			"inputGlassesImage": glassesImage,
			"inputGainMap": gainMap,
			"inputAperture": aperture,
			"inputLeftEyePositions": leftEyePositions,
			"inputRightEyePositions": rightEyePositions,
			"inputChinPositions": chinPositions,
			"inputNosePositions": nosePositions,
			"inputFocusRect": focusRectangle,
			"inputLumaNoiseScale": lumaNoiseScale,
			"inputScaleFactor": scaleFactor,
			"inputCalibrationData": calibrationData,
			"inputAuxDataMetadata": auxDataMetadata,
			"inputShape": shape,
		]) else { return self }
		return filter.outputImage ?? CIImage.empty()
	}

	/// Depth of Field
	///
	/// Simulates miniaturization effect created by Tilt & Shift lens by performing depth of field effects.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIDepthOfField)
	///
	/// Categories: Stylize, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - point0: The first point in the focused region of the output image.
	///   - point1: The second point in the focused region of the output image.
	///   - saturation: The amount to adjust the saturation. (0...)
	///   - unsharpMaskRadius: The radius of the unsharp mask effect applied to the in-focus area. (0...)
	///   - unsharpMaskIntensity: The intensity of the unsharp mask effect applied to the in-focus area. (0...)
	///   - radius: The distance from the center of the effect. (0...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func depthOfField(point0: CGPoint,
					  point1: CGPoint,
					  saturation: Float = 1.5,
					  unsharpMaskRadius: Float = 2.5,
					  unsharpMaskIntensity: Float = 0.5,
					  radius: Float = 6,
					  active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.depthOfField() // CIDepthOfField
		filter.inputImage = self
		filter.point0 = point0
		filter.point1 = point1
		filter.saturation = saturation
		filter.unsharpMaskRadius = unsharpMaskRadius
		filter.unsharpMaskIntensity = unsharpMaskIntensity
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Depth To Disparity
	///
	/// Convert a depth data image to disparity data.
	///
	/// ⚠️ No Apple Documentation available for 'CIDepthToDisparity'
	///
	/// Categories: Color Adjustment, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func depthToDisparity(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.depthToDisparity() // CIDepthToDisparity
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Difference Blend Mode
	///
	/// Subtracts either the source image sample color from the background image sample color, or the reverse, depending on which sample has the greater brightness value. Source image sample values that are black produce no change; white inverts the background color values.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIDifferenceBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func differenceBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.differenceBlendMode() // CIDifferenceBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Disc Blur
	///
	/// Smooths an image using a disc-shaped convolution kernel.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIDiscBlur)
	///
	/// Categories: Blur, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - radius: The radius determines how many pixels are used to create the blur. The larger the radius, the blurrier the result. (0...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func discBlur(radius: Float, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.discBlur() // CIDiscBlur
		filter.inputImage = self
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Disintegrate With Mask
	///
	/// Transitions from one image to another using the shape defined by a mask.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIDisintegrateWithMaskTransition)
	///
	/// Categories: Transition, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - targetImage: The target image for a transition.
	///   - maskImage: An image that defines the shape to use when disintegrating from the source to the target image.
	///   - time: The parametric time of the transition. This value drives the transition from start (at time 0) to end (at time 1). (0...1)
	///   - shadowRadius: The radius of the shadow created by the mask. (0...)
	///   - shadowDensity: The density of the shadow created by the mask. (0...1)
	///   - shadowOffset: The offset of the shadow created by the mask.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func disintegrateWithMaskTransition(targetImage: CIImage,
										maskImage: CIImage,
										time: Float,
										shadowRadius: Float,
										shadowDensity: Float = 0.65,
										shadowOffset: CGPoint) -> CIImage {
		guard shadowDensity != 0 else { return self }

		let filter = CIFilter.disintegrateWithMaskTransition() // CIDisintegrateWithMaskTransition
		filter.inputImage = self
		filter.targetImage = targetImage
		filter.maskImage = maskImage
		filter.time = time
		filter.shadowRadius = shadowRadius
		filter.shadowDensity = shadowDensity
		filter.shadowOffset = shadowOffset
		return filter.outputImage ?? CIImage.empty()
	}

	/// Disparity To Depth
	///
	/// Convert a disparity data image to depth data.
	///
	/// ⚠️ No Apple Documentation available for 'CIDisparityToDepth'
	///
	/// Categories: Color Adjustment, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func disparityToDepth(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.disparityToDepth() // CIDisparityToDepth
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Displacement Distortion
	///
	/// Applies the grayscale values of the second image to the first image. The output image has a texture defined by the grayscale values.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIDisplacementDistortion)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - displacementImage: An image whose grayscale values will be applied to the source image.
	///   - scale: The amount of texturing of the resulting image. The larger the value, the greater the texturing. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 14, macOS 11.0, *)
	func displacementDistortion(displacementImage: CIImage, scale: Float) -> CIImage {
		guard scale != 0 else { return self }

		let filter = CIFilter.displacementDistortion() // CIDisplacementDistortion
		filter.inputImage = self
		filter.displacementImage = displacementImage
		filter.scale = scale
		return filter.outputImage ?? CIImage.empty()
	}

	/// Dissolve
	///
	/// Uses a dissolve to transition from one image to another.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIDissolveTransition)
	///
	/// Categories: Transition, Video, Still Image, Interlaced, Non-Square Pixels, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - targetImage: The target image for a transition.
	///   - time: The parametric time of the transition. This value drives the transition from start (at time 0) to end (at time 1). (0...1)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func dissolveTransition(targetImage: CIImage, time: Float, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.dissolveTransition() // CIDissolveTransition
		filter.inputImage = self
		filter.targetImage = targetImage
		filter.time = time
		return filter.outputImage ?? CIImage.empty()
	}

	/// Dither
	///
	/// Apply dithering to an image. This operation is usually performed in a perceptual color space.
	///
	/// ⚠️ No Apple Documentation available for 'CIDither'
	///
	/// Categories: Color Effect, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - intensity: The intensity of the effect. (0...5)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func dither(intensity: Float = 0.1) -> CIImage {
		guard intensity != 0 else { return self }

		let filter = CIFilter.dither() // CIDither
		filter.inputImage = self
		filter.intensity = intensity
		return filter.outputImage ?? CIImage.empty()
	}

	/// Divide Blend Mode
	///
	/// Divides the background image sample color from the source image sample color.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIDivideBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func divideBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.divideBlendMode() // CIDivideBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Document Enhancer
	///
	/// Enhance a document image by removing unwanted shadows, whitening the background, and enhancing contrast.
	///
	/// ⚠️ No Apple Documentation available for 'CIDocumentEnhancer'
	///
	/// Categories: Color Effect, Non-Square Pixels, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - amount: The amount of enhancement. (0...10)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func documentEnhancer(amount: Float = 1, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.documentEnhancer() // CIDocumentEnhancer
		filter.inputImage = self
		filter.amount = amount
		return filter.outputImage ?? CIImage.empty()
	}

	/// Dot Screen
	///
	/// Simulates the dot patterns of a halftone screen.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIDotScreen)
	///
	/// Categories: Halftone Effect, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of the pattern.
	///   - width: The distance between dots in the pattern. (1...)
	///   - sharpness: The sharpness of the pattern. The larger the value, the sharper the pattern. (0...1)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func dotScreen(center: CGPoint, angle: Float = 0, width: Float, sharpness: Float = 0.7) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.dotScreen() // CIDotScreen
		filter.inputImage = self
		filter.center = center
		filter.angle = angle
		filter.width = width
		filter.sharpness = sharpness
		return filter.outputImage ?? CIImage.empty()
	}

	/// Droste
	///
	/// Recursively draws a portion of an image in imitation of an M. C. Escher drawing.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIDroste)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - insetPoint0: A vector that represents the first corner of the rectangular inset region.
	///   - insetPoint1: A vector that represents the second corner of the rectangular inset region.
	///   - strands: The number of droste strands (-10...10)
	///   - periodicity: The number of times that the image is repeated in each spiral of a stranded Droste image. (1...)
	///   - rotation: The amount by which to rotate the inset image.
	///   - zoom: A value that controls by how much to zoom the inset image (0.01...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func droste(insetPoint0: CGPoint,
				insetPoint1: CGPoint,
				strands: Float = 1,
				periodicity: Float = 1,
				rotation: Float = 0,
				zoom: Float = 1,
				active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.droste() // CIDroste
		filter.inputImage = self
		filter.insetPoint0 = insetPoint0
		filter.insetPoint1 = insetPoint1
		filter.strands = strands
		filter.periodicity = periodicity
		filter.rotation = rotation
		filter.zoom = zoom
		return filter.outputImage ?? CIImage.empty()
	}

	/// Edge Preserve Upsample Filter
	///
	/// Upsamples a small image to the size of the input image using the luminance of the input image as a guide to preserve detail.
	///
	/// ⚠️ No Apple Documentation available for 'CIEdgePreserveUpsampleFilter'
	///
	/// Categories: Geometry Adjustment, Video, Still Image, Interlaced, Non-Square Pixels, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - smallImage: The image that the filter upsamples.
	///   - spatialSigma: A value that specifies the influence of the input image's spatial information on the upsampling operation. (0...5)
	///   - lumaSigma: A value that specifies the influence of the input image's luma information on the upsampling operation. (0...1)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func edgePreserveUpsample(smallImage: CIImage,
							  spatialSigma: Float = 3,
							  lumaSigma: Float = 0.15,
							  active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.edgePreserveUpsample() // CIEdgePreserveUpsampleFilter
		filter.inputImage = self
		filter.smallImage = smallImage
		filter.spatialSigma = spatialSigma
		filter.lumaSigma = lumaSigma
		return filter.outputImage ?? CIImage.empty()
	}

	/// Edge Work
	///
	/// Produces a stylized black-and-white rendition of an image that looks similar to a woodblock cutout.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIEdgeWork)
	///
	/// Categories: Stylize, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - radius: The thickness of the edges. The larger the value, the thicker the edges. (0...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func edgeWork(radius: Float, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.edgeWork() // CIEdgeWork
		filter.inputImage = self
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Edges
	///
	/// Finds all edges in an image and displays them in color.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIEdges)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - intensity: The intensity of the edges. The larger the value, the higher the intensity. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func edges(intensity: Float = 1) -> CIImage {
		guard intensity != 0 else { return self }

		let filter = CIFilter.edges() // CIEdges
		filter.inputImage = self
		filter.intensity = intensity
		return filter.outputImage ?? CIImage.empty()
	}

	/// Eightfold Reflected Tile
	///
	/// Produces a tiled image from a source image by applying an 8-way reflected symmetry.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIEightfoldReflectedTile)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of the tiled pattern.
	///   - width: The width of a tile. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func eightfoldReflectedTile(center: CGPoint, angle: Float = 0, width: Float) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.eightfoldReflectedTile() // CIEightfoldReflectedTile
		filter.inputImage = self
		filter.center = center
		filter.angle = angle
		filter.width = width
		return filter.outputImage ?? CIImage.empty()
	}

	/// Exclusion Blend Mode
	///
	/// Produces an effect similar to that produced by the “Difference Blend Mode” filter but with lower contrast. Source image sample values that are black do not produce a change; white inverts the background color values.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIExclusionBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func exclusionBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.exclusionBlendMode() // CIExclusionBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Exposure Adjust
	///
	/// Adjusts the exposure setting for an image similar to the way you control exposure for a camera when you change the F-stop.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIExposureAdjust)
	///
	/// Categories: Color Adjustment, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In, CICategoryXMPSerializable
	///
	///
	/// - Parameters:
	///   - ev: The amount to adjust the exposure of the image by. The larger the value, the brighter the exposure.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func exposureAdjust(ev: Float = 0) -> CIImage {
		guard ev != 0 else { return self }

		let filter = CIFilter.exposureAdjust() // CIExposureAdjust
		filter.inputImage = self
		filter.ev = ev
		return filter.outputImage ?? CIImage.empty()
	}

	/// False Color
	///
	/// Maps luminance to a color ramp of two colors. False color is often used to process astronomical and other scientific data, such as ultraviolet and X-ray images.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIFalseColor)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - color0: The first color to use for the color ramp.
	///   - color1: The second color to use for the color ramp.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func falseColor(color0: CIColor, color1: CIColor, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.falseColor() // CIFalseColor
		filter.inputImage = self
		filter.color0 = color0
		filter.color1 = color1
		return filter.outputImage ?? CIImage.empty()
	}

	/// Flash
	///
	/// Transitions from one image to another by creating a flash. The flash originates from a point you specify. Small at first, it rapidly expands until the image frame is completely filled with the flash color. As the color fades, the target image begins to appear.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIFlashTransition)
	///
	/// Categories: Transition, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - targetImage: The target image for a transition.
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - extent: The extent of the flash.
	///   - color: The color of the light rays emanating from the flash.
	///   - time: The parametric time of the transition. This value drives the transition from start (at time 0) to end (at time 1). (0...1)
	///   - maxStriationRadius: The radius of the light rays emanating from the flash. (0...)
	///   - striationStrength: The strength of the light rays emanating from the flash. (0...)
	///   - striationContrast: The contrast of the light rays emanating from the flash. (0...)
	///   - fadeThreshold: The amount of fade between the flash and the target image. The higher the value, the more flash time and the less fade time. (0...1)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func flashTransition(targetImage: CIImage,
						 center: CGPoint,
						 extent: CGRect,
						 color: CIColor,
						 time: Float,
						 maxStriationRadius: Float = 2.58,
						 striationStrength: Float = 0.5,
						 striationContrast: Float = 1.375,
						 fadeThreshold: Float = 0.85,
						 active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.flashTransition() // CIFlashTransition
		filter.inputImage = self
		filter.targetImage = targetImage
		filter.center = center
		filter.extent = extent
		filter.color = color
		filter.time = time
		filter.maxStriationRadius = maxStriationRadius
		filter.striationStrength = striationStrength
		filter.striationContrast = striationContrast
		filter.fadeThreshold = fadeThreshold
		return filter.outputImage ?? CIImage.empty()
	}

	/// Fourfold Reflected Tile
	///
	/// Produces a tiled image from a source image by applying a 4-way reflected symmetry.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIFourfoldReflectedTile)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of the tiled pattern.
	///   - width: The width of a tile. (0...)
	///   - acuteAngle: The primary angle for the repeating reflected tile. Small values create thin diamond tiles, and higher values create fatter reflected tiles.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func fourfoldReflectedTile(center: CGPoint, angle: Float = 0, width: Float, acuteAngle: Float = .pi/2) -> CIImage {
		guard angle != 0 || acuteAngle != .pi/2 else { return self }

		let filter = CIFilter.fourfoldReflectedTile() // CIFourfoldReflectedTile
		filter.inputImage = self
		filter.center = center
		filter.angle = angle
		filter.width = width
		filter.acuteAngle = acuteAngle
		return filter.outputImage ?? CIImage.empty()
	}

	/// Fourfold Rotated Tile
	///
	/// Produces a tiled image from a source image by rotating the source image at increments of 90 degrees.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIFourfoldRotatedTile)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of the tiled pattern.
	///   - width: The width of a tile. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func fourfoldRotatedTile(center: CGPoint, angle: Float = 0, width: Float) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.fourfoldRotatedTile() // CIFourfoldRotatedTile
		filter.inputImage = self
		filter.center = center
		filter.angle = angle
		filter.width = width
		return filter.outputImage ?? CIImage.empty()
	}

	/// Fourfold Translated Tile
	///
	/// Produces a tiled image from a source image by applying 4 translation operations.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIFourfoldTranslatedTile)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of the tiled pattern.
	///   - width: The width of a tile. (0...)
	///   - acuteAngle: The primary angle for the repeating translated tile. Small values create thin diamond tiles, and higher values create fatter translated tiles.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func fourfoldTranslatedTile(center: CGPoint, angle: Float = 0, width: Float, acuteAngle: Float = .pi/2) -> CIImage {
		guard angle != 0 || acuteAngle != .pi/2 else { return self }

		let filter = CIFilter.fourfoldTranslatedTile() // CIFourfoldTranslatedTile
		filter.inputImage = self
		filter.center = center
		filter.angle = angle
		filter.width = width
		filter.acuteAngle = acuteAngle
		return filter.outputImage ?? CIImage.empty()
	}

	/// Gabor Gradients
	///
	/// Applies multichannel 5 by 5 Gabor gradient filter to an image. The resulting image has maximum horizontal gradient in the red channel and the maximum vertical gradient in the green channel. The gradient values can be positive or negative.
	///
	/// ⚠️ No Apple Documentation available for 'CIGaborGradients'
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func gaborGradients(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.gaborGradients() // CIGaborGradients
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Gamma Adjust
	///
	/// Adjusts midtone brightness. This filter is typically used to compensate for nonlinear effects of displays. Adjusting the gamma effectively changes the slope of the transition between black and white.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIGammaAdjust)
	///
	/// Categories: Color Adjustment, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - power: A gamma value to use to correct image brightness. The larger the value, the darker the result.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func gammaAdjust(power: Float = 1) -> CIImage {
		guard power != 1 else { return self }

		let filter = CIFilter.gammaAdjust() // CIGammaAdjust
		filter.inputImage = self
		filter.power = power
		return filter.outputImage ?? CIImage.empty()
	}

	/// Gaussian Blur
	///
	/// Spreads source pixels by an amount specified by a Gaussian distribution.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIGaussianBlur)
	///
	/// Categories: Blur, Still Image, Video, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - radius: The radius determines how many pixels are used to create the blur. The larger the radius, the blurrier the result. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func gaussianBlur(radius: Float = 10) -> CIImage {
		guard radius != 0 else { return self }

		let filter = CIFilter.gaussianBlur() // CIGaussianBlur
		filter.inputImage = self
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Glass Distortion
	///
	/// Distorts an image by applying a glass-like texture. The raised portions of the output image are the result of applying a texture map.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIGlassDistortion)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - textureImage: A texture to apply to the source image.
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - scale: The amount of texturing of the resulting image. The larger the value, the greater the texturing. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 14, macOS 11.0, *)
	func glassDistortion(textureImage: CIImage, center: CGPoint, scale: Float) -> CIImage {
		guard scale != 0 else { return self }

		let filter = CIFilter.glassDistortion() // CIGlassDistortion
		filter.inputImage = self
		filter.textureImage = textureImage
		filter.center = center
		filter.scale = scale
		return filter.outputImage ?? CIImage.empty()
	}

	/// Glass Lozenge
	///
	/// Creates a lozenge-shaped lens and distorts the portion of the image over which the lens is placed.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIGlassLozenge)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - point0: The x and y position that defines the center of the circle at one end of the lozenge.
	///   - point1: The x and y position that defines the center of the circle at the other end of the lozenge.
	///   - radius: The radius of the lozenge. The larger the radius, the wider the extent of the distortion. (0...)
	///   - refraction: The refraction of the glass. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 14, macOS 11.0, *)
	func glassLozenge(point0: CGPoint, point1: CGPoint, radius: Float, refraction: Float = 1.7) -> CIImage {
		guard refraction != 1 else { return self }

		let filter = CIFilter.glassLozenge() // CIGlassLozenge
		filter.inputImage = self
		filter.point0 = point0
		filter.point1 = point1
		filter.radius = radius
		filter.refraction = refraction
		return filter.outputImage ?? CIImage.empty()
	}

	/// Glide Reflected Tile
	///
	/// Produces a tiled image from a source image by translating and smearing the image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIGlideReflectedTile)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of the tiled pattern.
	///   - width: The width of a tile. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func glideReflectedTile(center: CGPoint, angle: Float = 0, width: Float) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.glideReflectedTile() // CIGlideReflectedTile
		filter.inputImage = self
		filter.center = center
		filter.angle = angle
		filter.width = width
		return filter.outputImage ?? CIImage.empty()
	}

	/// Gloom
	///
	/// Dulls the highlights of an image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIGloom)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - radius: The radius determines how many pixels are used to create the effect. The larger the radius, the greater the effect. (0...)
	///   - intensity: The intensity of the effect. A value of 0.0 is no effect. A value of 1.0 is the maximum effect. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func gloom(radius: Float, intensity: Float = 0.5) -> CIImage {
		guard radius != 0 || intensity != 0 else { return self }

		let filter = CIFilter.gloom() // CIGloom
		filter.inputImage = self
		filter.radius = radius
		filter.intensity = intensity
		return filter.outputImage ?? CIImage.empty()
	}

	/// Guided Filter
	///
	/// Upsamples a small image to the size of the guide image using the content of the guide to preserve detail.
	///
	/// ⚠️ No Apple Documentation available for 'CIGuidedFilter'
	///
	/// Categories: Geometry Adjustment, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - aLargerImageToUseAsAGuide: A larger image to use as a guide.
	///   - radius: The distance from the center of the effect.
	///   - epsilon: Smoothness. A higher value means more smoothing.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func guided(aLargerImageToUseAsAGuide: CIImage,
				radius: Float = 1,
				epsilon: Float = 0.0001,
				active: Bool = true) -> CIImage {
		guard active else { return self }

		// Filter not included in CoreImage.CIFilterBuiltins; using dictionary-based method.
		guard let filter = CIFilter(name: "CIGuidedFilter", parameters: [

			"inputGuideImage": aLargerImageToUseAsAGuide,
			"inputRadius": radius,
			"inputEpsilon": epsilon,
		]) else { return self }
		return filter.outputImage ?? CIImage.empty()
	}

	/// Hard Light Blend Mode
	///
	/// Either multiplies or screens colors, depending on the source image sample color. If the source image sample color is lighter than 50% gray, the background is lightened, similar to screening. If the source image sample color is darker than 50% gray, the background is darkened, similar to multiplying. If the source image sample color is equal to 50% gray, the source image is not changed. Image samples that are equal to pure black or pure white result in pure black or white. The overall effect is similar to what you would achieve by shining a harsh spotlight on the source image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIHardLightBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func hardLightBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.hardLightBlendMode() // CIHardLightBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Hatched Screen
	///
	/// Simulates the hatched pattern of a halftone screen.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIHatchedScreen)
	///
	/// Categories: Halftone Effect, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of the pattern.
	///   - width: The distance between lines in the pattern. (1...)
	///   - sharpness: The amount of sharpening to apply. (0...1)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func hatchedScreen(center: CGPoint, angle: Float = 0, width: Float, sharpness: Float = 0.7) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.hatchedScreen() // CIHatchedScreen
		filter.inputImage = self
		filter.center = center
		filter.angle = angle
		filter.width = width
		filter.sharpness = sharpness
		return filter.outputImage ?? CIImage.empty()
	}

	/// Height Field From Mask
	///
	/// Produces a continuous three-dimensional, loft-shaped height field from a grayscale mask. The white values of the mask define those pixels that are inside the height field while the black values define those pixels that are outside. The field varies smoothly and continuously inside the mask, reaching the value 0 at the edge of the mask. You can use this filter with the Shaded Material filter to produce extremely realistic shaded objects.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIHeightFieldFromMask)
	///
	/// Categories: Stylize, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - radius: The distance from the edge of the mask for the smooth transition is proportional to the input radius. Larger values make the transition smoother and more pronounced. Smaller values make the transition approximate a fillet radius. (0...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func heightFieldFromMask(radius: Float, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.heightFieldFromMask() // CIHeightFieldFromMask
		filter.inputImage = self
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Hexagonal Pixelate
	///
	/// Displays an image as colored hexagons whose color is an average of the pixels they replace.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIHexagonalPixellate)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - scale: The scale determines the size of the hexagons. Larger values result in larger hexagons. (1...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func hexagonalPixellate(center: CGPoint, scale: Float, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.hexagonalPixellate() // CIHexagonalPixellate
		filter.inputImage = self
		filter.center = center
		filter.scale = scale
		return filter.outputImage ?? CIImage.empty()
	}

	/// Highlight and Shadow Adjust
	///
	/// Adjust the tonal mapping of an image while preserving spatial detail.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIHighlightShadowAdjust)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - radius: Shadow Highlight Radius. (0...)
	///   - shadowAmount: The amount of adjustment to the shadows of the image. (-1...1)
	///   - highlightAmount: The amount of adjustment to the highlights of the image. (0...1)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func highlightShadowAdjust(radius: Float = 0, shadowAmount: Float = 0, highlightAmount: Float = 1) -> CIImage {
		guard radius != 0 || shadowAmount != 0 || highlightAmount != 1 else { return self }

		let filter = CIFilter.highlightShadowAdjust() // CIHighlightShadowAdjust
		filter.inputImage = self
		filter.radius = radius
		filter.shadowAmount = shadowAmount
		filter.highlightAmount = highlightAmount
		return filter.outputImage ?? CIImage.empty()
	}

	/// Histogram Display
	///
	/// Generates a displayable histogram image from the output of the “Area Histogram” filter.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIHistogramDisplayFilter)
	///
	/// Categories: Reduction, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - height: The height of the displayable histogram image. (1...200)
	///   - highLimit: The fraction of the right portion of the histogram image to make lighter. (0...1)
	///   - lowLimit: The fraction of the left portion of the histogram image to make darker. (0...1)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func histogramDisplay(height: Float = 100, highLimit: Float = 1, lowLimit: Float = 0, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.histogramDisplay() // CIHistogramDisplayFilter
		filter.inputImage = self
		filter.height = height
		filter.highLimit = highLimit
		filter.lowLimit = lowLimit
		return filter.outputImage ?? CIImage.empty()
	}

	/// Hole Distortion
	///
	/// Creates a circular area that pushes the image pixels outward, distorting those pixels closest to the circle the most.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIHoleDistortion)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - radius: The radius determines how many pixels are used to create the distortion. The larger the radius, the wider the extent of the distortion. (0.01...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func holeDistortion(center: CGPoint, radius: Float, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.holeDistortion() // CIHoleDistortion
		filter.inputImage = self
		filter.center = center
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Hue Adjust
	///
	/// Changes the overall hue, or tint, of the source pixels.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIHueAdjust)
	///
	/// Categories: Color Adjustment, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - angle: An angle in radians to use to correct the hue of an image.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func hueAdjust(angle: Float = 0) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.hueAdjust() // CIHueAdjust
		filter.inputImage = self
		filter.angle = angle
		return filter.outputImage ?? CIImage.empty()
	}

	/// Hue Blend Mode
	///
	/// Uses the luminance and saturation values of the background image with the hue of the input image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIHueBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func hueBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.hueBlendMode() // CIHueBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// KMeans
	///
	/// Create a palette of the most common colors found in the image.
	///
	/// ⚠️ No Apple Documentation available for 'CIKMeans'
	///
	/// Categories: Reduction, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that defines the extent of the effect.
	///   - inputMeans: Specifies the color seeds to use for k-means clustering, either passed as an image or an array of colors.
	///   - count: Specifies how many k-means color clusters should be used. (0...128)
	///   - passes: Specifies how many k-means passes should be performed. (0...20)
	///   - perceptual: Specifies whether the k-means color palette should be computed in a perceptual color space.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func kMeans(extent: CGRect,
				inputMeans: CIImage,
				count: Int,
				passes: Int,
				perceptual: Bool = false,
				active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.kMeans() // CIKMeans
		filter.inputImage = self
		filter.extent = extent
		filter.inputMeans = inputMeans
		filter.count = count
		filter.passes = Float(passes)
		filter.perceptual = perceptual
		return filter.outputImage ?? CIImage.empty()
	}

	/// Kaleidoscope
	///
	/// Produces a kaleidoscopic image from a source image by applying 12-way symmetry.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIKaleidoscope)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - count: The number of reflections in the pattern. (1...)
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of reflection.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func kaleidoscope(count: Int = 6, center: CGPoint, angle: Float = 0) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.kaleidoscope() // CIKaleidoscope
		filter.inputImage = self
		filter.count = count
		filter.center = center
		filter.angle = angle
		return filter.outputImage ?? CIImage.empty()
	}

	/// Combined Keystone Correction
	///
	/// Apply keystone correction to an image with combined horizontal and vertical guides.
	///
	/// ⚠️ No Apple Documentation available for 'CIKeystoneCorrectionCombined'
	///
	/// Categories: Geometry Adjustment, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - focalLength: 35mm equivalent focal length of the input image.
	///   - topLeft: The top left coordinate of the guide.
	///   - topRight: The top right coordinate of the guide.
	///   - bottomRight: The bottom right coordinate of the guide.
	///   - bottomLeft: The bottom left coordinate of the guide.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func keystoneCorrectionCombined(focalLength: Float = 28,
									topLeft: CGPoint,
									topRight: CGPoint,
									bottomRight: CGPoint,
									bottomLeft: CGPoint,
									active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.keystoneCorrectionCombined() // CIKeystoneCorrectionCombined
		filter.inputImage = self
		filter.focalLength = focalLength
		filter.topLeft = topLeft
		filter.topRight = topRight
		filter.bottomRight = bottomRight
		filter.bottomLeft = bottomLeft
		return filter.outputImage ?? CIImage.empty()
	}

	/// Horizontal Keystone Correction
	///
	/// Apply horizontal keystone correction to an image with guides.
	///
	/// ⚠️ No Apple Documentation available for 'CIKeystoneCorrectionHorizontal'
	///
	/// Categories: Geometry Adjustment, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - focalLength: 35mm equivalent focal length of the input image.
	///   - topLeft: The top left coordinate of the guide.
	///   - topRight: The top right coordinate of the guide.
	///   - bottomRight: The bottom right coordinate of the guide.
	///   - bottomLeft: The bottom left coordinate of the guide.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func keystoneCorrectionHorizontal(focalLength: Float = 28,
									  topLeft: CGPoint,
									  topRight: CGPoint,
									  bottomRight: CGPoint,
									  bottomLeft: CGPoint,
									  active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.keystoneCorrectionHorizontal() // CIKeystoneCorrectionHorizontal
		filter.inputImage = self
		filter.focalLength = focalLength
		filter.topLeft = topLeft
		filter.topRight = topRight
		filter.bottomRight = bottomRight
		filter.bottomLeft = bottomLeft
		return filter.outputImage ?? CIImage.empty()
	}

	/// Vertical Keystone Correction
	///
	/// Apply vertical keystone correction to an image with guides.
	///
	/// ⚠️ No Apple Documentation available for 'CIKeystoneCorrectionVertical'
	///
	/// Categories: Geometry Adjustment, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - focalLength: 35mm equivalent focal length of the input image.
	///   - topLeft: The top left coordinate of the guide.
	///   - topRight: The top right coordinate of the guide.
	///   - bottomRight: The bottom right coordinate of the guide.
	///   - bottomLeft: The bottom left coordinate of the guide.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func keystoneCorrectionVertical(focalLength: Float = 28,
									topLeft: CGPoint,
									topRight: CGPoint,
									bottomRight: CGPoint,
									bottomLeft: CGPoint,
									active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.keystoneCorrectionVertical() // CIKeystoneCorrectionVertical
		filter.inputImage = self
		filter.focalLength = focalLength
		filter.topLeft = topLeft
		filter.topRight = topRight
		filter.bottomRight = bottomRight
		filter.bottomLeft = bottomLeft
		return filter.outputImage ?? CIImage.empty()
	}

	/// Lab ∆E
	///
	/// Produces an image with the Lab ∆E difference values between two images. The result image will contain ∆E 1994 values between 0.0 and 100.0 where 2.0 is considered a just noticeable difference.
	///
	/// ⚠️ No Apple Documentation available for 'CILabDeltaE'
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - image2: The second input image for comparison.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func labDeltaE(image2: CIImage, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.labDeltaE() // CILabDeltaE
		filter.inputImage = self
		filter.image2 = image2
		return filter.outputImage ?? CIImage.empty()
	}

	/// Lanczos Scale Transform
	///
	/// Produces a high-quality, scaled version of a source image. You typically use this filter to scale down an image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CILanczosScaleTransform)
	///
	/// Categories: Geometry Adjustment, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - scale: The scaling factor to use on the image. Values less than 1.0 scale down the images. Values greater than 1.0 scale up the image. (0...)
	///   - aspectRatio: The additional horizontal scaling factor to use on the image. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func lanczosScaleTransform(scale: Float = 1, aspectRatio: Float = 1) -> CIImage {
		guard scale != 1 || aspectRatio != 1 else { return self }

		let filter = CIFilter.lanczosScaleTransform() // CILanczosScaleTransform
		filter.inputImage = self
		filter.scale = scale
		filter.aspectRatio = aspectRatio
		return filter.outputImage ?? CIImage.empty()
	}

	/// Light Tunnel Distortion
	///
	/// Rotates a portion of the input image specified by the center and radius parameters to give a tunneling effect.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CILightTunnel)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - rotation: Rotation angle in radians of the light tunnel.
	///   - radius: Center radius of the light tunnel.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 14, macOS 11.0, *)
	func lightTunnel(center: CGPoint, rotation: Float = 0, radius: Float) -> CIImage {
		guard rotation != 0 || radius != 0 else { return self }

		let filter = CIFilter.lightTunnel() // CILightTunnel
		filter.inputImage = self
		filter.center = center
		filter.rotation = rotation
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Lighten Blend Mode
	///
	/// Creates composite image samples by choosing the lighter samples (either from the source image or the background). The result is that the background image samples are replaced by any source image samples that are lighter. Otherwise, the background image samples are left unchanged.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CILightenBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func lightenBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.lightenBlendMode() // CILightenBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Line Overlay
	///
	/// Creates a sketch that outlines the edges of an image in black, leaving the non-outlined portions of the image transparent. The result has alpha and is rendered in black, so it won’t look like much until you render it over another image using source over compositing.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CILineOverlay)
	///
	/// Categories: Built-In, Still Image, Video, Stylize
	///
	///
	/// - Parameters:
	///   - nrNoiseLevel: The noise level of the image (used with camera data) that gets removed before tracing the edges of the image. Increasing the noise level helps to clean up the traced edges of the image. (0...)
	///   - nrSharpness: The amount of sharpening done when removing noise in the image before tracing the edges of the image. This improves the edge acquisition. (0...)
	///   - edgeIntensity: The accentuation factor of the Sobel gradient information when tracing the edges of the image. Higher values find more edges, although typically a low value (such as 1.0) is used. (0...)
	///   - threshold: This value determines edge visibility. Larger values thin out the edges. (0...)
	///   - contrast: The amount of anti-aliasing to use on the edges produced by this filter. Higher values produce higher contrast edges (they are less anti-aliased). (0.25...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func lineOverlay(nrNoiseLevel: Float = 0.07,
					 nrSharpness: Float = 0.71,
					 edgeIntensity: Float = 1,
					 threshold: Float = 0.1,
					 contrast: Float = 50) -> CIImage {
		guard nrNoiseLevel != 0 || nrSharpness != 0 || edgeIntensity != 0 || threshold != 0 || contrast != 1 else { return self }

		let filter = CIFilter.lineOverlay() // CILineOverlay
		filter.inputImage = self
		filter.nrNoiseLevel = nrNoiseLevel
		filter.nrSharpness = nrSharpness
		filter.edgeIntensity = edgeIntensity
		filter.threshold = threshold
		filter.contrast = contrast
		return filter.outputImage ?? CIImage.empty()
	}

	/// Line Screen
	///
	/// Simulates the line pattern of a halftone screen.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CILineScreen)
	///
	/// Categories: Halftone Effect, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of the pattern.
	///   - width: The distance between lines in the pattern. (1...)
	///   - sharpness: The sharpness of the pattern. The larger the value, the sharper the pattern. (0...1)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func lineScreen(center: CGPoint, angle: Float = 0, width: Float, sharpness: Float = 0.7) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.lineScreen() // CILineScreen
		filter.inputImage = self
		filter.center = center
		filter.angle = angle
		filter.width = width
		filter.sharpness = sharpness
		return filter.outputImage ?? CIImage.empty()
	}

	/// Linear Burn Blend Mode
	///
	/// Inverts the unpremultiplied source and background image sample color, inverts the sum, and then blends the result with the background according to the PDF basic compositing formula. Source image values that are white produce no change. Source image values that are black invert the background color values.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CILinearBurnBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func linearBurnBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.linearBurnBlendMode() // CILinearBurnBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Linear Dodge Blend Mode
	///
	/// Unpremultiplies the source and background image sample colors, adds them, and then blends the result with the background according to the PDF basic compositing formula. Source image values that are black produces output that is the same as the background. Source image values that are non-black brighten the background color values.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CILinearDodgeBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func linearDodgeBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.linearDodgeBlendMode() // CILinearDodgeBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Linear Light Blend Mode
	///
	/// A blend mode that is a combination of linear burn and linear dodge blend modes.
	///
	/// ⚠️ No Apple Documentation available for 'CILinearLightBlendMode'
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 15, macOS 12.0, *)
	func linearLightBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.linearLightBlendMode() // CILinearLightBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Linear to sRGB Tone Curve
	///
	/// Maps color intensity from a linear gamma curve to the sRGB color space.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CILinearToSRGBToneCurve)
	///
	/// Categories: Color Adjustment, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func linearToSRGBToneCurve(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.linearToSRGBToneCurve() // CILinearToSRGBToneCurve
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Luminosity Blend Mode
	///
	/// Uses the hue and saturation of the background with the luminance of the source image. This mode creates an effect that is inverse to the effect created by the “Color Blend Mode” filter.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CILuminosityBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func luminosityBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.luminosityBlendMode() // CILuminosityBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Mask to Alpha
	///
	/// Converts a grayscale image to a white image that is masked by alpha. The white values from the source image produce the inside of the mask; the black values become completely transparent.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIMaskToAlpha)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func maskToAlpha(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.maskToAlpha() // CIMaskToAlpha
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Masked Variable Blur
	///
	/// Blurs the source image according to the brightness levels in a mask image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIMaskedVariableBlur)
	///
	/// Categories: Blur, Still Image, Video, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - mask: The mask image that determines how much to blur the image. The mask’s green channel value from 0.0 to 1.0 determines if the image is not blurred or blurred by the full radius.
	///   - radius: A value that governs the maximum blur radius to apply. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func maskedVariableBlur(mask: CIImage, radius: Float = 5) -> CIImage {
		guard radius != 0 else { return self }

		let filter = CIFilter.maskedVariableBlur() // CIMaskedVariableBlur
		filter.inputImage = self
		filter.mask = mask
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Maximum Component
	///
	/// Converts an image to grayscale using the maximum of the three color components.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIMaximumComponent)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: a grayscale image from max(r,g,b), or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func maximumComponent(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.maximumComponent() // CIMaximumComponent
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Maximum
	///
	/// Computes the maximum value, by color component, of two input images and creates an output image using the maximum values. This is similar to dodging.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIMaximumCompositing)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func maximumCompositing(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.maximumCompositing() // CIMaximumCompositing
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Median
	///
	/// Computes the median value for a group of neighboring pixels and replaces each pixel value with the median. The effect is to reduce noise.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIMedianFilter)
	///
	/// Categories: Blur, Still Image, Video, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func median(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.median() // CIMedianFilter
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Minimum Component
	///
	/// Converts an image to grayscale using the minimum of the three color components.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIMinimumComponent)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: a grayscale image from min(r,g,b), or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func minimumComponent(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.minimumComponent() // CIMinimumComponent
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Minimum
	///
	/// Computes the minimum value, by color component, of two input images and creates an output image using the minimum values. This is similar to burning.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIMinimumCompositing)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func minimumCompositing(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.minimumCompositing() // CIMinimumCompositing
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Mix
	///
	/// Uses an amount parameter to interpolate between an image and a background image. When value is 0.0 or less, the result is the background image. When the value is 1.0 or more, the result is the image.
	///
	/// ⚠️ No Apple Documentation available for 'CIMix'
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	///   - amount: The amount of the effect.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func mix(backgroundImage: CIImage?, amount: Float = 1) -> CIImage {
		guard amount != 1 else { return self }

		let filter = CIFilter.mix() // CIMix
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		filter.amount = amount
		return filter.outputImage ?? CIImage.empty()
	}

	/// Mod
	///
	/// Transitions from one image to another by revealing the target image through irregularly shaped holes.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIModTransition)
	///
	/// Categories: Transition, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - targetImage: The target image for a transition.
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - time: The parametric time of the transition. This value drives the transition from start (at time 0) to end (at time 1). (0...1)
	///   - angle: The angle in radians of the mod hole pattern.
	///   - radius: The radius of the undistorted holes in the pattern. (1...)
	///   - compression: The amount of stretching applied to the mod hole pattern. Holes in the center are not distorted as much as those at the edge of the image. (1...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func modTransition(targetImage: CIImage,
					   center: CGPoint,
					   time: Float,
					   angle: Float = 2,
					   radius: Float,
					   compression: Float) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.modTransition() // CIModTransition
		filter.inputImage = self
		filter.targetImage = targetImage
		filter.center = center
		filter.time = time
		filter.angle = angle
		filter.radius = radius
		filter.compression = compression
		return filter.outputImage ?? CIImage.empty()
	}

	/// Morphology Gradient
	///
	/// Finds the edges of an image by returning the difference between the morphological minimum and maximum operations to the image.
	///
	/// ⚠️ No Apple Documentation available for 'CIMorphologyGradient'
	///
	/// Categories: Blur, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - radius: The desired radius of the circular morphological operation to the image. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func morphologyGradient(radius: Float) -> CIImage {
		guard radius != 0 else { return self }

		let filter = CIFilter.morphologyGradient() // CIMorphologyGradient
		filter.inputImage = self
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Morphology Maximum
	///
	/// Lightens areas of an image by applying a circular morphological maximum operation to the image.
	///
	/// ⚠️ No Apple Documentation available for 'CIMorphologyMaximum'
	///
	/// Categories: Blur, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - radius: The desired radius of the circular morphological operation to the image.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func morphologyMaximum(radius: Float = 0) -> CIImage {
		guard radius != 0 else { return self }

		let filter = CIFilter.morphologyMaximum() // CIMorphologyMaximum
		filter.inputImage = self
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Morphology Minimum
	///
	/// Darkens areas of an image by applying a circular morphological maximum operation to the image.
	///
	/// ⚠️ No Apple Documentation available for 'CIMorphologyMinimum'
	///
	/// Categories: Blur, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - radius: The desired radius of the circular morphological operation to the image.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func morphologyMinimum(radius: Float = 0) -> CIImage {
		guard radius != 0 else { return self }

		let filter = CIFilter.morphologyMinimum() // CIMorphologyMinimum
		filter.inputImage = self
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Morphology Rectangle Maximum
	///
	/// Lightens areas of an image by applying a rectangular morphological maximum operation to the image.
	///
	/// ⚠️ No Apple Documentation available for 'CIMorphologyRectangleMaximum'
	///
	/// Categories: Blur, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - width: The width in pixels of the morphological operation. (1...)
	///   - height: The height in pixels of the morphological operation. (1...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func morphologyRectangleMaximum(width: Int, height: Int, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.morphologyRectangleMaximum() // CIMorphologyRectangleMaximum
		filter.inputImage = self
		filter.width = Float(width)
		filter.height = Float(height)
		return filter.outputImage ?? CIImage.empty()
	}

	/// Morphology Rectangle Minimum
	///
	/// Darkens areas of an image by applying a rectangular morphological maximum operation to the image.
	///
	/// ⚠️ No Apple Documentation available for 'CIMorphologyRectangleMinimum'
	///
	/// Categories: Blur, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - width: The width in pixels of the morphological operation. (1...)
	///   - height: The height in pixels of the morphological operation. (1...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func morphologyRectangleMinimum(width: Int, height: Int, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.morphologyRectangleMinimum() // CIMorphologyRectangleMinimum
		filter.inputImage = self
		filter.width = Float(width)
		filter.height = Float(height)
		return filter.outputImage ?? CIImage.empty()
	}

	/// Motion Blur
	///
	/// Blurs an image to simulate the effect of using a camera that moves a specified angle and distance while capturing the image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIMotionBlur)
	///
	/// Categories: Blur, Still Image, Video, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - radius: The radius determines how many pixels are used to create the blur. The larger the radius, the blurrier the result. (0...)
	///   - angle: The angle in radians of the motion determines which direction the blur smears.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func motionBlur(radius: Float, angle: Float = 0) -> CIImage {
		guard radius != 0 || angle != 0 else { return self }

		let filter = CIFilter.motionBlur() // CIMotionBlur
		filter.inputImage = self
		filter.radius = radius
		filter.angle = angle
		return filter.outputImage ?? CIImage.empty()
	}

	/// Multiply Blend Mode
	///
	/// Multiplies the source image samples with the background image samples. This results in colors that are at least as dark as either of the two contributing sample colors.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIMultiplyBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func multiplyBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.multiplyBlendMode() // CIMultiplyBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Multiply
	///
	/// Multiplies the color component of two input images and creates an output image using the multiplied values. This filter is typically used to add a spotlight or similar lighting effect to an image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIMultiplyCompositing)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func multiplyCompositing(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.multiplyCompositing() // CIMultiplyCompositing
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Nine Part Stretched
	///
	/// Distorts an image by stretching an image based on two input breakpoints.
	///
	/// ⚠️ No Apple Documentation available for 'CINinePartStretched'
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - breakpoint0: Lower left corner of image to retain before stretching begins.
	///   - breakpoint1: Upper right corner of image to retain after stretching ends.
	///   - growAmount: Vector indicating how much image should grow in pixels in both dimensions.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func ninePartStretched(breakpoint0: CGPoint,
						   breakpoint1: CGPoint,
						   growAmount: CGPoint = .init(x: 100, y: 100),
						   active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.ninePartStretched() // CINinePartStretched
		filter.inputImage = self
		filter.breakpoint0 = breakpoint0
		filter.breakpoint1 = breakpoint1
		filter.growAmount = growAmount
		return filter.outputImage ?? CIImage.empty()
	}

	/// Nine Part Tiled
	///
	/// Distorts an image by tiling an image based on two input breakpoints.
	///
	/// ⚠️ No Apple Documentation available for 'CINinePartTiled'
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - breakpoint0: Lower left corner of image to retain before tiling begins.
	///   - breakpoint1: Upper right corner of image to retain after tiling ends.
	///   - growAmount: Vector indicating how much image should grow in pixels in both dimensions.
	///   - flipYTiles: Indicates that Y-Axis flip should occur.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func ninePartTiled(breakpoint0: CGPoint,
					   breakpoint1: CGPoint,
					   growAmount: CGPoint = .init(x: 100, y: 100),
					   flipYTiles: Bool = true,
					   active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.ninePartTiled() // CINinePartTiled
		filter.inputImage = self
		filter.breakpoint0 = breakpoint0
		filter.breakpoint1 = breakpoint1
		filter.growAmount = growAmount
		filter.flipYTiles = flipYTiles
		return filter.outputImage ?? CIImage.empty()
	}

	/// Noise Reduction
	///
	/// Reduces noise using a threshold value to define what is considered noise. Small changes in luminance below that value are considered noise and get a noise reduction treatment, which is a local blur. Changes above the threshold value are considered edges, so they are sharpened.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CINoiseReduction)
	///
	/// Categories: Blur, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - noiseLevel: The amount of noise reduction. The larger the value, the more noise reduction. (0...)
	///   - sharpness: The sharpness of the final image. The larger the value, the sharper the result. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func noiseReduction(noiseLevel: Float = 0.02, sharpness: Float = 0.4) -> CIImage {
		guard noiseLevel != 0 || sharpness != 0 else { return self }

		let filter = CIFilter.noiseReduction() // CINoiseReduction
		filter.inputImage = self
		filter.noiseLevel = noiseLevel
		filter.sharpness = sharpness
		return filter.outputImage ?? CIImage.empty()
	}

	/// Op Tile
	///
	/// Segments an image, applying any specified scaling and rotation, and then assembles the image again to give an op art appearance.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIOpTile)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - scale: The scale determines the number of tiles in the effect. (0...)
	///   - angle: The angle in radians of a tile.
	///   - width: The width of a tile. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func opTile(center: CGPoint, scale: Float = 2.8, angle: Float = 0, width: Float) -> CIImage {
		guard scale != 1 || angle != 0 else { return self }

		let filter = CIFilter.opTile() // CIOpTile
		filter.inputImage = self
		filter.center = center
		filter.scale = scale
		filter.angle = angle
		filter.width = width
		return filter.outputImage ?? CIImage.empty()
	}

	/// Overlay Blend Mode
	///
	/// Either multiplies or screens the source image samples with the background image samples, depending on the background color. The result is to overlay the existing image samples while preserving the highlights and shadows of the background. The background color mixes with the source image to reflect the lightness or darkness of the background.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIOverlayBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func overlayBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.overlayBlendMode() // CIOverlayBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Page Curl
	///
	/// Transitions from one image to another by simulating a curling page, revealing the new image as the page curls.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPageCurlTransition)
	///
	/// Categories: Transition, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - targetImage: The target image for a transition.
	///   - backsideImage: The image that appears on the back of the source image, as the page curls to reveal the target image.
	///   - shadingImage: An image that looks like a shaded sphere enclosed in a square image.
	///   - extent: The extent of the effect.
	///   - time: The parametric time of the transition. This value drives the transition from start (at time 0) to end (at time 1). (0...1)
	///   - angle: The angle in radians of the curling page.
	///   - radius: The radius of the curl. (0.01...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func pageCurlTransition(targetImage: CIImage,
							backsideImage: CIImage,
							shadingImage: CIImage,
							extent: CGRect,
							time: Float,
							angle: Float = 0,
							radius: Float) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.pageCurlTransition() // CIPageCurlTransition
		filter.inputImage = self
		filter.targetImage = targetImage
		filter.backsideImage = backsideImage
		filter.shadingImage = shadingImage
		filter.extent = extent
		filter.time = time
		filter.angle = angle
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Page Curl With Shadow
	///
	/// Transitions from one image to another by simulating a curling page, revealing the new image as the page curls.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPageCurlWithShadowTransition)
	///
	/// Categories: Transition, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - targetImage: The target image for a transition.
	///   - backsideImage: The image that appears on the back of the source image, as the page curls to reveal the target image.
	///   - extent: The extent of the effect.
	///   - time: The parametric time of the transition. This value drives the transition from start (at time 0) to end (at time 1). (0...1)
	///   - angle: The angle in radians of the curling page.
	///   - radius: The radius of the curl. (0.01...)
	///   - shadowSize: The maximum size in pixels of the shadow. (0...1)
	///   - shadowAmount: The strength of the shadow. (0...1)
	///   - shadowExtent: The rectagular portion of input image that will cast a shadow.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func pageCurlWithShadowTransition(targetImage: CIImage,
									  backsideImage: CIImage,
									  extent: CGRect = .zero,
									  time: Float,
									  angle: Float = 0,
									  radius: Float,
									  shadowSize: Float,
									  shadowAmount: Float,
									  shadowExtent: CGRect = .zero) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.pageCurlWithShadowTransition() // CIPageCurlWithShadowTransition
		filter.inputImage = self
		filter.targetImage = targetImage
		filter.backsideImage = backsideImage
		filter.extent = extent
		filter.time = time
		filter.angle = angle
		filter.radius = radius
		filter.shadowSize = shadowSize
		filter.shadowAmount = shadowAmount
		filter.shadowExtent = shadowExtent
		return filter.outputImage ?? CIImage.empty()
	}

	/// Palette Centroid
	///
	/// Calculate the mean (x,y) image coordinates of a color palette.
	///
	/// ⚠️ No Apple Documentation available for 'CIPaletteCentroid'
	///
	/// Categories: Color Effect, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - paletteImage: The input color palette, obtained using “CIKMeans“ filter.
	///   - perceptual: Specifies whether the color palette should be applied in a perceptual color space.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func paletteCentroid(paletteImage: CIImage, perceptual: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.paletteCentroid() // CIPaletteCentroid
		filter.inputImage = self
		filter.paletteImage = paletteImage
		filter.perceptual = perceptual
		return filter.outputImage ?? CIImage.empty()
	}

	/// Palettize
	///
	/// Paint an image from a color palette obtained using “CIKMeans“.
	///
	/// ⚠️ No Apple Documentation available for 'CIPalettize'
	///
	/// Categories: Color Effect, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - paletteImage: The input color palette, obtained using “CIKMeans“ filter.
	///   - perceptual: Specifies whether the color palette should be applied in a perceptual color space.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func palettize(paletteImage: CIImage, perceptual: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.palettize() // CIPalettize
		filter.inputImage = self
		filter.paletteImage = paletteImage
		filter.perceptual = perceptual
		return filter.outputImage ?? CIImage.empty()
	}

	/// Parallelogram Tile
	///
	/// Warps an image by reflecting it in a parallelogram, and then tiles the result.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIParallelogramTile)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of the tiled pattern.
	///   - acuteAngle: The primary angle for the repeating parallelogram tile. Small values create thin diamond tiles, and higher values create fatter parallelogram tiles.
	///   - width: The width of a tile. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func parallelogramTile(center: CGPoint, angle: Float = 0, acuteAngle: Float = .pi/2, width: Float) -> CIImage {
		guard angle != 0 || acuteAngle != .pi/2 else { return self }

		let filter = CIFilter.parallelogramTile() // CIParallelogramTile
		filter.inputImage = self
		filter.center = center
		filter.angle = angle
		filter.acuteAngle = acuteAngle
		filter.width = width
		return filter.outputImage ?? CIImage.empty()
	}

	/// Person Segmentation
	///
	/// Returns a segmentation mask that is red in the portions of an image that are likely to be persons. The returned image may have a different size and aspect ratio from the input image.
	///
	/// ⚠️ No Apple Documentation available for 'CIPersonSegmentation'
	///
	/// Categories: Video, Still Image, Built-In, Stylize
	///
	///
	/// - Parameters:
	///   - qualityLevel: Determines the size and quality of the resulting segmentation mask. The value can be a number where 0 is accurate, 1 is balanced, and 2 is fast. (0...2)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 15, macOS 12.0, *)
	func personSegmentation(qualityLevel: Int, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.personSegmentation() // CIPersonSegmentation
		filter.inputImage = self
		filter.qualityLevel = qualityLevel
		return filter.outputImage ?? CIImage.empty()
	}

	/// Perspective Correction
	///
	/// Applies a perspective correction, transforming an arbitrary quadrilateral region in the source image to a rectangular output image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPerspectiveCorrection)
	///
	/// Categories: Geometry Adjustment, Still Image, Video, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - topLeft: The top left coordinate to be perspective corrected.
	///   - topRight: The top right coordinate to be perspective corrected.
	///   - bottomRight: The bottom right coordinate to be perspective corrected.
	///   - bottomLeft: The bottom left coordinate to be perspective corrected.
	///   - crop: A rectangle that specifies the extent of the corrected image.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func perspectiveCorrection(topLeft: CGPoint,
							   topRight: CGPoint,
							   bottomRight: CGPoint,
							   bottomLeft: CGPoint,
							   crop: Bool = true,
							   active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.perspectiveCorrection() // CIPerspectiveCorrection
		filter.inputImage = self
		filter.topLeft = topLeft
		filter.topRight = topRight
		filter.bottomRight = bottomRight
		filter.bottomLeft = bottomLeft
		filter.crop = crop
		return filter.outputImage ?? CIImage.empty()
	}

	/// Perspective Rotate
	///
	/// Apply a homogenous rotation transform to an image.
	///
	/// ⚠️ No Apple Documentation available for 'CIPerspectiveRotate'
	///
	/// Categories: Geometry Adjustment, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - focalLength: 35mm equivalent focal length of the input image.
	///   - pitch: Pitch angle in radians.
	///   - yaw: Yaw angle in radians.
	///   - roll: Roll angle in radians.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func perspectiveRotate(focalLength: Float = 28, pitch: Float = 0, yaw: Float = 0, roll: Float = 0) -> CIImage {
		guard pitch != 0 || yaw != 0 || roll != 0 else { return self }

		let filter = CIFilter.perspectiveRotate() // CIPerspectiveRotate
		filter.inputImage = self
		filter.focalLength = focalLength
		filter.pitch = pitch
		filter.yaw = yaw
		filter.roll = roll
		return filter.outputImage ?? CIImage.empty()
	}

	/// Perspective Tile
	///
	/// Applies a perspective transform to an image and then tiles the result.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPerspectiveTile)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - topLeft: The top left coordinate of a tile.
	///   - topRight: The top right coordinate of a tile.
	///   - bottomRight: The bottom right coordinate of a tile.
	///   - bottomLeft: The bottom left coordinate of a tile.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func perspectiveTile(topLeft: CGPoint,
						 topRight: CGPoint,
						 bottomRight: CGPoint,
						 bottomLeft: CGPoint,
						 active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.perspectiveTile() // CIPerspectiveTile
		filter.inputImage = self
		filter.topLeft = topLeft
		filter.topRight = topRight
		filter.bottomRight = bottomRight
		filter.bottomLeft = bottomLeft
		return filter.outputImage ?? CIImage.empty()
	}

	/// Perspective Transform
	///
	/// Alters the geometry of an image to simulate the observer changing viewing position. You can use the perspective filter to skew an image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPerspectiveTransform)
	///
	/// Categories: Geometry Adjustment, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - topLeft: The top left coordinate to map the image to.
	///   - topRight: The top right coordinate to map the image to.
	///   - bottomRight: The bottom right coordinate to map the image to.
	///   - bottomLeft: The bottom left coordinate to map the image to.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func perspectiveTransform(topLeft: CGPoint,
							  topRight: CGPoint,
							  bottomRight: CGPoint,
							  bottomLeft: CGPoint,
							  active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.perspectiveTransform() // CIPerspectiveTransform
		filter.inputImage = self
		filter.topLeft = topLeft
		filter.topRight = topRight
		filter.bottomRight = bottomRight
		filter.bottomLeft = bottomLeft
		return filter.outputImage ?? CIImage.empty()
	}

	/// Perspective Transform with Extent
	///
	/// Alters the geometry of an image to simulate the observer changing viewing position. You can use the perspective filter to skew an image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPerspectiveTransformWithExtent)
	///
	/// Categories: Geometry Adjustment, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that defines the extent of the effect.
	///   - topLeft: The top left coordinate to map the image to.
	///   - topRight: The top right coordinate to map the image to.
	///   - bottomRight: The bottom right coordinate to map the image to.
	///   - bottomLeft: The bottom left coordinate to map the image to.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func perspectiveTransformWithExtent(extent: CGRect,
										topLeft: CGPoint,
										topRight: CGPoint,
										bottomRight: CGPoint,
										bottomLeft: CGPoint,
										active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.perspectiveTransformWithExtent() // CIPerspectiveTransformWithExtent
		filter.inputImage = self
		filter.extent = extent
		filter.topLeft = topLeft
		filter.topRight = topRight
		filter.bottomRight = bottomRight
		filter.bottomLeft = bottomLeft
		return filter.outputImage ?? CIImage.empty()
	}

	/// Photo Effect Chrome
	///
	/// Applies a preconfigured set of effects that imitate vintage photography film with exaggerated color.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPhotoEffectChrome)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In, CICategoryXMPSerializable
	///
	///
	/// - Parameters:
	///   - extrapolate: If true, then the color effect will be extrapolated if the input image contains RGB component values outside the range 0.0 to 1.0.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func photoEffectChrome(extrapolate: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.photoEffectChrome() // CIPhotoEffectChrome
		filter.inputImage = self
		filter.extrapolate = extrapolate
		return filter.outputImage ?? CIImage.empty()
	}

	/// Photo Effect Fade
	///
	/// Applies a preconfigured set of effects that imitate vintage photography film with diminished color.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPhotoEffectFade)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In, CICategoryXMPSerializable
	///
	///
	/// - Parameters:
	///   - extrapolate: If true, then the color effect will be extrapolated if the input image contains RGB component values outside the range 0.0 to 1.0.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func photoEffectFade(extrapolate: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.photoEffectFade() // CIPhotoEffectFade
		filter.inputImage = self
		filter.extrapolate = extrapolate
		return filter.outputImage ?? CIImage.empty()
	}

	/// Photo Effect Instant
	///
	/// Applies a preconfigured set of effects that imitate vintage photography film with distorted colors.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPhotoEffectInstant)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In, CICategoryXMPSerializable
	///
	///
	/// - Parameters:
	///   - extrapolate: If true, then the color effect will be extrapolated if the input image contains RGB component values outside the range 0.0 to 1.0.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func photoEffectInstant(extrapolate: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.photoEffectInstant() // CIPhotoEffectInstant
		filter.inputImage = self
		filter.extrapolate = extrapolate
		return filter.outputImage ?? CIImage.empty()
	}

	/// Photo Effect Mono
	///
	/// Applies a preconfigured set of effects that imitate black-and-white photography film with low contrast.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPhotoEffectMono)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In, CICategoryXMPSerializable
	///
	///
	/// - Parameters:
	///   - extrapolate: If true, then the color effect will be extrapolated if the input image contains RGB component values outside the range 0.0 to 1.0.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func photoEffectMono(extrapolate: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.photoEffectMono() // CIPhotoEffectMono
		filter.inputImage = self
		filter.extrapolate = extrapolate
		return filter.outputImage ?? CIImage.empty()
	}

	/// Photo Effect Noir
	///
	/// Applies a preconfigured set of effects that imitate black-and-white photography film with exaggerated contrast.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPhotoEffectNoir)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In, CICategoryXMPSerializable
	///
	///
	/// - Parameters:
	///   - extrapolate: If true, then the color effect will be extrapolated if the input image contains RGB component values outside the range 0.0 to 1.0.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func photoEffectNoir(extrapolate: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.photoEffectNoir() // CIPhotoEffectNoir
		filter.inputImage = self
		filter.extrapolate = extrapolate
		return filter.outputImage ?? CIImage.empty()
	}

	/// Photo Effect Process
	///
	/// Applies a preconfigured set of effects that imitate vintage photography film with emphasized cool colors.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPhotoEffectProcess)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In, CICategoryXMPSerializable
	///
	///
	/// - Parameters:
	///   - extrapolate: If true, then the color effect will be extrapolated if the input image contains RGB component values outside the range 0.0 to 1.0.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func photoEffectProcess(extrapolate: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.photoEffectProcess() // CIPhotoEffectProcess
		filter.inputImage = self
		filter.extrapolate = extrapolate
		return filter.outputImage ?? CIImage.empty()
	}

	/// Photo Effect Tonal
	///
	/// Applies a preconfigured set of effects that imitate black-and-white photography film without significantly altering contrast.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPhotoEffectTonal)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In, CICategoryXMPSerializable
	///
	///
	/// - Parameters:
	///   - extrapolate: If true, then the color effect will be extrapolated if the input image contains RGB component values outside the range 0.0 to 1.0.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func photoEffectTonal(extrapolate: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.photoEffectTonal() // CIPhotoEffectTonal
		filter.inputImage = self
		filter.extrapolate = extrapolate
		return filter.outputImage ?? CIImage.empty()
	}

	/// Photo Effect Transfer
	///
	/// Applies a preconfigured set of effects that imitate vintage photography film with emphasized warm colors.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPhotoEffectTransfer)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In, CICategoryXMPSerializable
	///
	///
	/// - Parameters:
	///   - extrapolate: If true, then the color effect will be extrapolated if the input image contains RGB component values outside the range 0.0 to 1.0.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func photoEffectTransfer(extrapolate: Bool = false, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.photoEffectTransfer() // CIPhotoEffectTransfer
		filter.inputImage = self
		filter.extrapolate = extrapolate
		return filter.outputImage ?? CIImage.empty()
	}

	/// Pin Light Blend Mode
	///
	/// Unpremultiplies the source and background image sample color, combines them according to the relative difference, and then blends the result with the background according to the PDF basic compositing formula. Source image values that are brighter than the destination will produce an output that is lighter than the destination. Source image values that are darker than the destination will produce an output that is darker than the destination.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPinLightBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func pinLightBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.pinLightBlendMode() // CIPinLightBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Pinch Distortion
	///
	/// Creates a rectangular-shaped area that pinches source pixels inward, distorting those pixels closest to the rectangle the most.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPinchDistortion)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - radius: The radius determines how many pixels are used to create the distortion. The larger the radius, the wider the extent of the distortion. (0...)
	///   - scale: The amount of pinching. A value of 0.0 has no effect. A value of 1.0 is the maximum pinch. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 14, macOS 11.0, *)
	func pinchDistortion(center: CGPoint, radius: Float, scale: Float = 0.5) -> CIImage {
		guard radius != 0 || scale != 0 else { return self }

		let filter = CIFilter.pinchDistortion() // CIPinchDistortion
		filter.inputImage = self
		filter.center = center
		filter.radius = radius
		filter.scale = scale
		return filter.outputImage ?? CIImage.empty()
	}

	/// Pixelate
	///
	/// Makes an image blocky by mapping the image to colored squares whose color is defined by the replaced pixels.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPixellate)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - scale: The scale determines the size of the squares. Larger values result in larger squares. (1...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func pixellate(center: CGPoint, scale: Float, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.pixellate() // CIPixellate
		filter.inputImage = self
		filter.center = center
		filter.scale = scale
		return filter.outputImage ?? CIImage.empty()
	}

	/// Pointillize
	///
	/// Renders the source image in a pointillistic style.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPointillize)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - radius: The radius of the circles in the resulting pattern. (1...)
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func pointillize(radius: Float, center: CGPoint, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.pointillize() // CIPointillize
		filter.inputImage = self
		filter.radius = radius
		filter.center = center
		return filter.outputImage ?? CIImage.empty()
	}

	/// Ripple
	///
	/// Transitions from one image to another by creating a circular wave that expands from the center point, revealing the new image in the wake of the wave.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIRippleTransition)
	///
	/// Categories: Transition, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - targetImage: The target image for a transition.
	///   - shadingImage: An image that looks like a shaded sphere enclosed in a square image.
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - extent: A rectangle that defines the extent of the effect.
	///   - time: The parametric time of the transition. This value drives the transition from start (at time 0) to end (at time 1). (0...1)
	///   - width: The width of the ripple. (1...)
	///   - scale: A value that determines whether the ripple starts as a bulge (higher value) or a dimple (lower value). (-50...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func rippleTransition(targetImage: CIImage,
						  shadingImage: CIImage,
						  center: CGPoint,
						  extent: CGRect,
						  time: Float,
						  width: Float,
						  scale: Float = 50) -> CIImage {
		guard scale != 0 else { return self }

		let filter = CIFilter.rippleTransition() // CIRippleTransition
		filter.inputImage = self
		filter.targetImage = targetImage
		filter.shadingImage = shadingImage
		filter.center = center
		filter.extent = extent
		filter.time = time
		filter.width = width
		filter.scale = scale
		return filter.outputImage ?? CIImage.empty()
	}

	/// Row Average
	///
	/// Calculates the average color for each row of the specified area in an image, returning the result in a 1D image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIRowAverage)
	///
	/// Categories: Reduction, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that specifies the subregion of the image that you want to process.
	///   - active: should this filter be applied
	/// - Returns: a 1-pixel high image that contains the average color for each scan row, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func rowAverage(extent: CGRect, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.rowAverage() // CIRowAverage
		filter.inputImage = self
		filter.extent = extent
		return filter.outputImage ?? CIImage.empty()
	}

	/// sRGB Tone Curve to Linear
	///
	/// Maps color intensity from the sRGB color space to a linear gamma curve.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISRGBToneCurveToLinear)
	///
	/// Categories: Color Adjustment, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func sRGBToneCurveToLinear(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.sRGBToneCurveToLinear() // CISRGBToneCurveToLinear
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Saliency Map Filter
	///
	/// Generates output image as a saliency map of the input image.
	///
	/// ⚠️ No Apple Documentation available for 'CISaliencyMapFilter'
	///
	/// Categories: Video, Still Image, Built-In, Stylize
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func saliencyMap(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.saliencyMap() // CISaliencyMapFilter
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	// NOTE: CISampleNearest already has a CIImage method: func samplingNearest() -> CIImage


	/// Saturation Blend Mode
	///
	/// Uses the luminance and hue values of the background with the saturation of the source image. Areas of the background that have no saturation (that is, pure gray areas) do not produce a change.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISaturationBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func saturationBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.saturationBlendMode() // CISaturationBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Screen Blend Mode
	///
	/// Multiplies the inverse of the source image samples with the inverse of the background image samples. This results in colors that are at least as light as either of the two contributing sample colors.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIScreenBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func screenBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.screenBlendMode() // CIScreenBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Sepia Tone
	///
	/// Maps the colors of an image to various shades of brown.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISepiaTone)
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, High Dynamic Range, Built-In, CICategoryXMPSerializable
	///
	///
	/// - Parameters:
	///   - intensity: The intensity of the sepia effect. A value of 1.0 creates a monochrome sepia image. A value of 0.0 has no effect on the image. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func sepiaTone(intensity: Float = 1) -> CIImage {
		guard intensity != 0 else { return self }

		let filter = CIFilter.sepiaTone() // CISepiaTone
		filter.inputImage = self
		filter.intensity = intensity
		return filter.outputImage ?? CIImage.empty()
	}

	/// Shaded Material
	///
	/// Produces a shaded image from a height field. The height field is defined to have greater heights with lighter shades, and lesser heights (lower areas) with darker shades. You can combine this filter with the “Height Field From Mask” filter to produce quick shadings of masks, such as text.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIShadedMaterial)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - shadingImage: The image to use as the height field. The resulting image has greater heights with lighter shades, and lesser heights (lower areas) with darker shades.
	///   - scale: The scale of the effect. The higher the value, the more dramatic the effect. (0...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func shadedMaterial(shadingImage: CIImage, scale: Float, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.shadedMaterial() // CIShadedMaterial
		filter.inputImage = self
		filter.shadingImage = shadingImage
		filter.scale = scale
		return filter.outputImage ?? CIImage.empty()
	}

	/// Sharpen Luminance
	///
	/// Increases image detail by sharpening. It operates on the luminance of the image; the chrominance of the pixels remains unaffected.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISharpenLuminance)
	///
	/// Categories: Sharpen, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - sharpness: The amount of sharpening to apply. Larger values are sharper.
	///   - radius: The distance from the center of the effect.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func sharpenLuminance(sharpness: Float = 0.4, radius: Float = 1.69) -> CIImage {
		guard sharpness != 0 || radius != 0 else { return self }

		let filter = CIFilter.sharpenLuminance() // CISharpenLuminance
		filter.inputImage = self
		filter.sharpness = sharpness
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Sixfold Reflected Tile
	///
	/// Produces a tiled image from a source image by applying a 6-way reflected symmetry.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISixfoldReflectedTile)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of the tiled pattern.
	///   - width: The width of a tile. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func sixfoldReflectedTile(center: CGPoint, angle: Float = 0, width: Float) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.sixfoldReflectedTile() // CISixfoldReflectedTile
		filter.inputImage = self
		filter.center = center
		filter.angle = angle
		filter.width = width
		return filter.outputImage ?? CIImage.empty()
	}

	/// Sixfold Rotated Tile
	///
	/// Produces a tiled image from a source image by rotating the source image at increments of 60 degrees.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISixfoldRotatedTile)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of the tiled pattern.
	///   - width: The width of a tile. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func sixfoldRotatedTile(center: CGPoint, angle: Float = 0, width: Float) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.sixfoldRotatedTile() // CISixfoldRotatedTile
		filter.inputImage = self
		filter.center = center
		filter.angle = angle
		filter.width = width
		return filter.outputImage ?? CIImage.empty()
	}

	/// Sobel Gradients
	///
	/// Applies multichannel 3 by 3 Sobel gradient filter to an image. The resulting image has maximum horizontal gradient in the red channel and the maximum vertical gradient in the green channel. The gradient values can be positive or negative.
	///
	/// ⚠️ No Apple Documentation available for 'CISobelGradients'
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 17, macOS 14.0, *)
	func sobelGradients(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.sobelGradients() // CISobelGradients
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Soft Light Blend Mode
	///
	/// Either darkens or lightens colors, depending on the source image sample color. If the source image sample color is lighter than 50% gray, the background is lightened, similar to dodging. If the source image sample color is darker than 50% gray, the background is darkened, similar to burning. If the source image sample color is equal to 50% gray, the background is not changed. Image samples that are equal to pure black or pure white produce darker or lighter areas, but do not result in pure black or white. The overall effect is similar to what you would achieve by shining a diffuse spotlight on the source image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISoftLightBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func softLightBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.softLightBlendMode() // CISoftLightBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Source Atop
	///
	/// Places the source image over the background image, then uses the luminance of the background image to determine what to show. The composite shows the background image and only those portions of the source image that are over visible parts of the background.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISourceAtopCompositing)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func sourceAtopCompositing(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.sourceAtopCompositing() // CISourceAtopCompositing
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Source In
	///
	/// Uses the background image to define what to leave in the input image, effectively cropping the input image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISourceInCompositing)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func sourceInCompositing(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.sourceInCompositing() // CISourceInCompositing
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Source Out
	///
	/// Uses the background image to define what to take out of the input image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISourceOutCompositing)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func sourceOutCompositing(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.sourceOutCompositing() // CISourceOutCompositing
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Source Over
	///
	/// Places the input image over the input background image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISourceOverCompositing)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func sourceOverCompositing(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.sourceOverCompositing() // CISourceOverCompositing
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Spot Color
	///
	/// Replaces one or more color ranges with spot colors.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISpotColor)
	///
	/// Categories: Built-In, Still Image, Video, High Dynamic Range, Stylize
	///
	///
	/// - Parameters:
	///   - centerColor1: The center value of the first color range to replace.
	///   - replacementColor1: A replacement color for the first color range.
	///   - closeness1: A value that indicates how close the first color must match before it is replaced. (0...)
	///   - contrast1: The contrast of the first replacement color. (0...)
	///   - centerColor2: The center value of the second color range to replace.
	///   - replacementColor2: A replacement color for the second color range.
	///   - closeness2: A value that indicates how close the second color must match before it is replaced. (0...)
	///   - contrast2: The contrast of the second replacement color. (0...)
	///   - centerColor3: The center value of the third color range to replace.
	///   - replacementColor3: A replacement color for the third color range.
	///   - closeness3: A value that indicates how close the third color must match before it is replaced. (0...)
	///   - contrast3: The contrast of the third replacement color. (0...)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func spotColor(centerColor1: CIColor,
				   replacementColor1: CIColor,
				   closeness1: Float = 0.22,
				   contrast1: Float = 0.98,
				   centerColor2: CIColor,
				   replacementColor2: CIColor,
				   closeness2: Float = 0.15,
				   contrast2: Float = 0.98,
				   centerColor3: CIColor,
				   replacementColor3: CIColor,
				   closeness3: Float = 0.5,
				   contrast3: Float = 0.99,
				   active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.spotColor() // CISpotColor
		filter.inputImage = self
		filter.centerColor1 = centerColor1
		filter.replacementColor1 = replacementColor1
		filter.closeness1 = closeness1
		filter.contrast1 = contrast1
		filter.centerColor2 = centerColor2
		filter.replacementColor2 = replacementColor2
		filter.closeness2 = closeness2
		filter.contrast2 = contrast2
		filter.centerColor3 = centerColor3
		filter.replacementColor3 = replacementColor3
		filter.closeness3 = closeness3
		filter.contrast3 = contrast3
		return filter.outputImage ?? CIImage.empty()
	}

	/// Spot Light
	///
	/// Applies a directional spotlight effect to an image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISpotLight)
	///
	/// Categories: Stylize, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - lightPosition: The x and y position of the spotlight.
	///   - lightPointsAt: The x and y position that the spotlight points at.
	///   - brightness: The brightness of the spotlight. (0...)
	///   - concentration: The spotlight size. The smaller the value, the more tightly focused the light beam. (0.001...)
	///   - color: The color of the spotlight.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func spotLight(lightPosition: CIVector,
				   lightPointsAt: CIVector,
				   brightness: Float,
				   concentration: Float = 0.1,
				   color: CIColor = CIColor.white) -> CIImage {
		guard concentration != 20 else { return self }

		let filter = CIFilter.spotLight() // CISpotLight
		filter.inputImage = self
		filter.lightPosition = lightPosition
		filter.lightPointsAt = lightPointsAt
		filter.brightness = brightness
		filter.concentration = concentration
		filter.color = color
		return filter.outputImage ?? CIImage.empty()
	}

	/// Straighten
	///
	/// Rotates a source image by the specified angle in radians. The image is then scaled and cropped so that the rotated image fits the extent of the input image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIStraightenFilter)
	///
	/// Categories: Geometry Adjustment, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - angle: The angle in radians of the effect.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func straighten(angle: Float = 0) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.straighten() // CIStraightenFilter
		filter.inputImage = self
		filter.angle = angle
		return filter.outputImage ?? CIImage.empty()
	}

	/// Stretch Crop
	///
	/// Distorts an image by stretching and or cropping it to fit a target size.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIStretchCrop)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - size: The size in pixels of the output image.
	///   - cropAmount: Determines if and how much cropping should be used to achieve the target size. If value is 0 then only stretching is used. If 1 then only cropping is used. (0...1)
	///   - centerStretchAmount: Determine how much the center of the image is stretched if stretching is used. If value is 0 then the center of the image maintains the original aspect ratio. If 1 then the image is stretched uniformly. (0...1)
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 14, macOS 11.0, *)
	func stretchCrop(size: CGPoint,
					 cropAmount: Float = 0.25,
					 centerStretchAmount: Float = 0.25,
					 active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.stretchCrop() // CIStretchCrop
		filter.inputImage = self
		filter.size = size
		filter.cropAmount = cropAmount
		filter.centerStretchAmount = centerStretchAmount
		return filter.outputImage ?? CIImage.empty()
	}

	/// Subtract Blend Mode
	///
	/// Unpremultiplies the source and background image sample colors, subtracts the source from the background, and then blends the result with the background according to the PDF basic compositing formula. Source image values that are black produces output that is the same as the background. Source image values that are non-black darken the background color values.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISubtractBlendMode)
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 13, macOS 10.15, *)
	func subtractBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.subtractBlendMode() // CISubtractBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Swipe
	///
	/// Transitions from one image to another by simulating a swiping action.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISwipeTransition)
	///
	/// Categories: Transition, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - targetImage: The target image for a transition.
	///   - extent: The extent of the effect.
	///   - color: The color of the swipe.
	///   - time: The parametric time of the transition. This value drives the transition from start (at time 0) to end (at time 1). (0...1)
	///   - angle: The angle in radians of the swipe.
	///   - width: The width of the swipe. (0.1...)
	///   - opacity: The opacity of the swipe. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func swipeTransition(targetImage: CIImage,
						 extent: CGRect,
						 color: CIColor = CIColor.white,
						 time: Float,
						 angle: Float = 0,
						 width: Float,
						 opacity: Float = 0) -> CIImage {
		guard angle != 0 || opacity != 0 else { return self }

		let filter = CIFilter.swipeTransition() // CISwipeTransition
		filter.inputImage = self
		filter.targetImage = targetImage
		filter.extent = extent
		filter.color = color
		filter.time = time
		filter.angle = angle
		filter.width = width
		filter.opacity = opacity
		return filter.outputImage ?? CIImage.empty()
	}

	/// Temperature and Tint
	///
	/// Adapts the reference white point for an image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CITemperatureAndTint)
	///
	/// Categories: Color Adjustment, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - neutral: A vector containing the source white point defined by color temperature and tint or chromaticity (x,y).
	///   - targetNeutral: A vector containing the desired white point defined by color temperature and tint or chromaticity (x,y).
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func temperatureAndTint(neutral: CIVector, targetNeutral: CIVector, active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.temperatureAndTint() // CITemperatureAndTint
		filter.inputImage = self
		filter.neutral = neutral
		filter.targetNeutral = targetNeutral
		return filter.outputImage ?? CIImage.empty()
	}

	/// Thermal
	///
	/// Apply a “Thermal” style effect to an image.
	///
	/// ⚠️ No Apple Documentation available for 'CIThermal'
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func thermal(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.thermal() // CIThermal
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Tone Curve
	///
	/// Adjusts tone response of the R, G, and B channels of an image. The input points are five x,y values that are interpolated using a spline curve. The curve is applied in a perceptual (gamma 2) version of the working space.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIToneCurve)
	///
	/// Categories: Color Adjustment, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - point0: A vector containing the position of the first point of the tone curve.
	///   - point1: A vector containing the position of the second point of the tone curve.
	///   - point2: A vector containing the position of the third point of the tone curve.
	///   - point3: A vector containing the position of the fourth point of the tone curve.
	///   - point4: A vector containing the position of the fifth point of the tone curve.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func toneCurve(point0: CGPoint,
				   point1: CGPoint = .init(x: 0.25, y: 0.25),
				   point2: CGPoint = .init(x: 0.5, y: 0.5),
				   point3: CGPoint = .init(x: 0.75, y: 0.75),
				   point4: CGPoint = .init(x: 1, y: 1)) -> CIImage {
		guard point1 != .init(x: 0.25, y: 0.25) || point2 != .init(x: 0.5, y: 0.5) || point3 != .init(x: 0.75, y: 0.75) || point4 != .init(x: 1, y: 1) else { return self }

		let filter = CIFilter.toneCurve() // CIToneCurve
		filter.inputImage = self
		filter.point0 = point0
		filter.point1 = point1
		filter.point2 = point2
		filter.point3 = point3
		filter.point4 = point4
		return filter.outputImage ?? CIImage.empty()
	}

	/// Torus Lens Distortion
	///
	/// Creates a torus-shaped lens and distorts the portion of the image over which the lens is placed.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CITorusLensDistortion)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - radius: The outer radius of the torus. (0...)
	///   - width: The width of the ring. (0...)
	///   - refraction: The refraction of the glass. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 14, macOS 11.0, *)
	func torusLensDistortion(center: CGPoint, radius: Float, width: Float, refraction: Float = 1.7) -> CIImage {
		guard radius != 0 || width != 0 || refraction != 1 else { return self }

		let filter = CIFilter.torusLensDistortion() // CITorusLensDistortion
		filter.inputImage = self
		filter.center = center
		filter.radius = radius
		filter.width = width
		filter.refraction = refraction
		return filter.outputImage ?? CIImage.empty()
	}

	/// Triangle Kaleidoscope
	///
	/// Maps a triangular portion of image to a triangular area and then generates a kaleidoscope effect.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CITriangleKaleidoscope)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - point: The x and y position to use as the center of the triangular area in the input image.
	///   - size: The size in pixels of the triangle.
	///   - rotation: Rotation angle in radians of the triangle.
	///   - decay: The decay determines how fast the color fades from the center triangle.
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func triangleKaleidoscope(point: CGPoint,
							  size: Float = 700,
							  rotation: Float,
							  decay: Float = 0.85,
							  active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.triangleKaleidoscope() // CITriangleKaleidoscope
		filter.inputImage = self
		filter.point = point
		filter.size = size
		filter.rotation = rotation
		filter.decay = decay
		return filter.outputImage ?? CIImage.empty()
	}

	/// Triangle Tile
	///
	/// Maps a triangular portion of image to a triangular area and then tiles the result.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CITriangleTile)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of the tiled pattern.
	///   - width: The width of a tile. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func triangleTile(center: CGPoint, angle: Float = 0, width: Float) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.triangleTile() // CITriangleTile
		filter.inputImage = self
		filter.center = center
		filter.angle = angle
		filter.width = width
		return filter.outputImage ?? CIImage.empty()
	}

	/// Twelvefold Reflected Tile
	///
	/// Produces a tiled image from a source image by rotating the source image at increments of 30 degrees.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CITwelvefoldReflectedTile)
	///
	/// Categories: Tile Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - angle: The angle in radians of the tiled pattern.
	///   - width: The width of a tile. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func twelvefoldReflectedTile(center: CGPoint, angle: Float = 0, width: Float) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.twelvefoldReflectedTile() // CITwelvefoldReflectedTile
		filter.inputImage = self
		filter.center = center
		filter.angle = angle
		filter.width = width
		return filter.outputImage ?? CIImage.empty()
	}

	/// Twirl Distortion
	///
	/// Rotates pixels around a point to give a twirling effect. You can specify the number of rotations as well as the center and radius of the effect.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CITwirlDistortion)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - radius: The radius determines how many pixels are used to create the distortion. The larger the radius, the wider the extent of the distortion. (0...)
	///   - angle: The angle in radians of the twirl. Values can be positive or negative.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 14, macOS 11.0, *)
	func twirlDistortion(center: CGPoint, radius: Float, angle: Float = .pi) -> CIImage {
		guard angle != 0 else { return self }

		let filter = CIFilter.twirlDistortion() // CITwirlDistortion
		filter.inputImage = self
		filter.center = center
		filter.radius = radius
		filter.angle = angle
		return filter.outputImage ?? CIImage.empty()
	}

	/// Unsharp Mask
	///
	/// Increases the contrast of the edges between pixels of different colors in an image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIUnsharpMask)
	///
	/// Categories: Sharpen, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - radius: The radius around a given pixel to apply the unsharp mask. The larger the radius, the more of the image is affected. (0...)
	///   - intensity: The intensity of the effect. The larger the value, the more contrast in the affected area. (0...)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func unsharpMask(radius: Float, intensity: Float = 0.5) -> CIImage {
		guard radius != 0 || intensity != 0 else { return self }

		let filter = CIFilter.unsharpMask() // CIUnsharpMask
		filter.inputImage = self
		filter.radius = radius
		filter.intensity = intensity
		return filter.outputImage ?? CIImage.empty()
	}

	/// Vibrance
	///
	/// Adjusts the saturation of an image while keeping pleasing skin tones.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIVibrance)
	///
	/// Categories: Color Adjustment, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - amount: The amount to adjust the saturation. (-1...1)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func vibrance(amount: Float = 0) -> CIImage {
		guard amount != 0 else { return self }

		let filter = CIFilter.vibrance() // CIVibrance
		filter.inputImage = self
		filter.amount = amount
		return filter.outputImage ?? CIImage.empty()
	}

	/// Vignette
	///
	/// Applies a vignette shading to the corners of an image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIVignette)
	///
	/// Categories: Color Effect, Video, Interlaced, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - intensity: The intensity of the effect. (-1...1)
	///   - radius: The distance from the center of the effect. (0...2)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func vignette(intensity: Float = 0, radius: Float = 1) -> CIImage {
		guard intensity != 0 else { return self }

		let filter = CIFilter.vignette() // CIVignette
		filter.inputImage = self
		filter.intensity = intensity
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Vignette Effect
	///
	/// Modifies the brightness of an image around the periphery of a specified region.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIVignetteEffect)
	///
	/// Categories: Color Effect, Video, Interlaced, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - radius: The distance from the center of the effect. (0...)
	///   - intensity: The intensity of the effect. (-1...1)
	///   - falloff: The falloff of the effect. (0...1)
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func vignetteEffect(center: CGPoint, radius: Float, intensity: Float = 1, falloff: Float = 0.5) -> CIImage {
		guard intensity != 0 else { return self }

		let filter = CIFilter.vignetteEffect() // CIVignetteEffect
		filter.inputImage = self
		filter.center = center
		filter.radius = radius
		filter.intensity = intensity
		filter.falloff = falloff
		return filter.outputImage ?? CIImage.empty()
	}

	/// Vivid Light Blend Mode
	///
	/// A blend mode that is a combination of color burn and color dodge blend modes.
	///
	/// ⚠️ No Apple Documentation available for 'CIVividLightBlendMode'
	///
	/// Categories: Composite Operation, Video, Still Image, Interlaced, Non-Square Pixels, Built-In
	///
	///
	/// - Parameters:
	///   - backgroundImage: The image to use as a background image.
	/// - Returns: processed new `CIImage`, or identity if `backgroundImage` is nil
	@available(iOS 15, macOS 12.0, *)
	func vividLightBlendMode(backgroundImage: CIImage?) -> CIImage {
		guard let backgroundImage else { return self }

		let filter = CIFilter.vividLightBlendMode() // CIVividLightBlendMode
		filter.inputImage = self
		filter.backgroundImage = backgroundImage
		return filter.outputImage ?? CIImage.empty()
	}

	/// Vortex Distortion
	///
	/// Rotates pixels around a point to simulate a vortex. You can specify the number of rotations as well the center and radius of the effect.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIVortexDistortion)
	///
	/// Categories: Distortion Effect, Video, Still Image, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - radius: The radius determines how many pixels are used to create the distortion. The larger the radius, the wider the extent of the distortion. (0...)
	///   - angle: The angle in radians of the effect.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 14, macOS 11.0, *)
	func vortexDistortion(center: CGPoint, radius: Float, angle: Float) -> CIImage {
		guard radius != 0 || angle != 0 else { return self }

		let filter = CIFilter.vortexDistortion() // CIVortexDistortion
		filter.inputImage = self
		filter.center = center
		filter.radius = radius
		filter.angle = angle
		return filter.outputImage ?? CIImage.empty()
	}

	/// White Point Adjust
	///
	/// Adjusts the reference white point for an image and maps all colors in the source using the new reference.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIWhitePointAdjust)
	///
	/// Categories: Color Adjustment, Video, Still Image, Interlaced, Non-Square Pixels, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - color: A color to use as the white point.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func whitePointAdjust(color: CIColor = CIColor.white) -> CIImage {
		guard color != CIColor.white else { return self }

		let filter = CIFilter.whitePointAdjust() // CIWhitePointAdjust
		filter.inputImage = self
		filter.color = color
		return filter.outputImage ?? CIImage.empty()
	}

	/// X-Ray
	///
	/// Apply an “XRay” style effect to an image.
	///
	/// ⚠️ No Apple Documentation available for 'CIXRay'
	///
	/// Categories: Color Effect, Video, Interlaced, Non-Square Pixels, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - active: should this filter be applied
	/// - Returns: processed new `CIImage`, or identity if `active` is false
	@available(iOS 13, macOS 10.15, *)
	func xRay(active: Bool = true) -> CIImage {
		guard active else { return self }

		let filter = CIFilter.xRay() // CIXRay
		filter.inputImage = self

		return filter.outputImage ?? CIImage.empty()
	}

	/// Zoom Blur
	///
	/// Simulates the effect of zooming the camera while capturing the image.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIZoomBlur)
	///
	/// Categories: Blur, Still Image, Video, Built-In, High Dynamic Range
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - amount: The zoom-in amount. Larger values result in more zooming in.
	/// - Returns: processed new `CIImage` or identity if parameters result in no operation applied
	@available(iOS 13, macOS 10.15, *)
	func zoomBlur(center: CGPoint, amount: Float) -> CIImage {
		guard amount != 0 else { return self }

		let filter = CIFilter.zoomBlur() // CIZoomBlur
		filter.inputImage = self
		filter.center = center
		filter.amount = amount
		return filter.outputImage ?? CIImage.empty()
	}

	//
	// MARK: GENERATORS
	//

	/// Attributed Text Image Generator
	///
	/// Generate an image attributed string.
	///
	/// ⚠️ No Apple Documentation available for 'CIAttributedTextImageGenerator'
	///
	/// Categories: Generator, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - text: The attributed text to render.
	///   - scaleFactor: The scale of the font to use for the generated text. (0...)
	///   - padding: A value for an additional number of pixels to pad around the text’s bounding box. (0...200)
	/// - Returns: an image attributed string
	@available(iOS 16, macOS 13.0, *)
	static func attributedTextImageGenerator(text: NSAttributedString, scaleFactor: Float = 1, padding: Int) -> CIImage {
		let filter = CIFilter.attributedTextImageGenerator() // CIAttributedTextImageGenerator
		filter.text = text
		filter.scaleFactor = scaleFactor
		filter.padding = Float(padding)
		return filter.outputImage ?? CIImage.empty()
	}

	/// Aztec Code Generator
	///
	/// Generates an Aztec code (two-dimensional barcode) from input data.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIAztecCodeGenerator)
	///
	/// Categories: Generator, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - message: The message to encode in the Aztec Barcode
	///   - correctionLevel: Aztec error correction value between 5 and 95 (5...95)
	///   - layers: Aztec layers value between 1 and 32. (1...32)
	///   - compactStyle: A Boolean that specifies whether to force a compact style Aztec code.
	/// - Returns: an Aztec code (two-dimensional barcode) from input data
	@available(iOS 13, macOS 10.15, *)
	static func aztecCodeGenerator(message: Data, correctionLevel: Int, layers: Int, compactStyle: Bool) -> CIImage {
		let filter = CIFilter.aztecCodeGenerator() // CIAztecCodeGenerator
		filter.message = message
		filter.correctionLevel = Float(correctionLevel)
		filter.layers = Float(layers)
		filter.compactStyle = Float(compactStyle ? 1 : 0)
		return filter.outputImage ?? CIImage.empty()
	}

	/// Barcode Generator
	///
	/// Generate a barcode image from a CIBarcodeDescriptor.
	///
	/// ⚠️ No Apple Documentation available for 'CIBarcodeGenerator'
	///
	/// Categories: Generator, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - barcodeDescriptor: The CIBarcodeDescription object to generate an image for.
	/// - Returns: a barcode image from a CIBarcodeDescriptor
	@available(iOS 13, macOS 10.15, *)
	static func barcodeGenerator(barcodeDescriptor: CIBarcodeDescriptor) -> CIImage {
		let filter = CIFilter.barcodeGenerator() // CIBarcodeGenerator
		filter.barcodeDescriptor = barcodeDescriptor
		return filter.outputImage ?? CIImage.empty()
	}

	/// Blurred Rectangle Generator
	///
	/// Generates a blurred rectangle image with the specified extent, blur sigma, and color.
	///
	/// ⚠️ No Apple Documentation available for 'CIBlurredRectangleGenerator'
	///
	/// Categories: Generator, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that defines the extent of the effect.
	///   - sigma: The sigma for a gaussian blur. (0...)
	///   - color: A color.
	/// - Returns: a blurred rectangle image with the specified extent, blur sigma, and color
	@available(iOS 17, macOS 14.0, *)
	static func blurredRectangleGenerator(extent: CGRect, sigma: Float, color: CIColor = CIColor.white) -> CIImage {
		let filter = CIFilter.blurredRectangleGenerator() // CIBlurredRectangleGenerator
		filter.extent = extent
		filter.sigma = sigma
		filter.color = color
		return filter.outputImage ?? CIImage.empty()
	}

	/// Checkerboard
	///
	/// Generates a pattern of squares of alternating colors. You can specify the size, colors, and the sharpness of the pattern.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CICheckerboardGenerator)
	///
	/// Categories: Generator, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - color0: A color to use for the first set of squares.
	///   - color1: A color to use for the second set of squares.
	///   - width: The width of the squares in the pattern.
	///   - sharpness: The sharpness of the edges in pattern. The smaller the value, the more blurry the pattern. Values range from 0.0 to 1.0. (0...1)
	/// - Returns: a checkerboard pattern
	@available(iOS 13, macOS 10.15, *)
	static func checkerboardGenerator(center: CGPoint,
									  color0: CIColor = CIColor.white,
									  color1: CIColor = CIColor.black,
									  width: Float,
									  sharpness: Float = 1) -> CIImage {
		let filter = CIFilter.checkerboardGenerator() // CICheckerboardGenerator
		filter.center = center
		filter.color0 = color0
		filter.color1 = color1
		filter.width = width
		filter.sharpness = sharpness
		return filter.outputImage ?? CIImage.empty()
	}

	/// Code 128 Barcode Generator
	///
	/// Generates a Code 128 one-dimensional barcode from input data.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CICode128BarcodeGenerator)
	///
	/// Categories: Generator, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - message: The message to encode in the Code 128 Barcode
	///   - quietSpace: The number of empty white pixels that should surround the barcode. (0...100)
	///   - barcodeHeight: The height of the generated barcode in pixels. (1...500)
	/// - Returns: a Code 128 one-dimensional barcode from input data
	@available(iOS 13, macOS 10.15, *)
	static func code128BarcodeGenerator(message: Data, quietSpace: Int, barcodeHeight: Int) -> CIImage {
		let filter = CIFilter.code128BarcodeGenerator() // CICode128BarcodeGenerator
		filter.message = message
		filter.quietSpace = Float(quietSpace)
		filter.barcodeHeight = Float(barcodeHeight)
		return filter.outputImage ?? CIImage.empty()
	}
	// ℹ️ CIConstantColorGenerator already has a CIImage initializer: init(color: CIColor)

	/// Gaussian Gradient
	///
	/// Generates a gradient that varies from one color to another using a Gaussian distribution.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIGaussianGradient)
	///
	/// Categories: Gradient, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - color0: The first color to use in the gradient.
	///   - color1: The second color to use in the gradient.
	///   - radius: The radius of the Gaussian distribution. (0...)
	/// - Returns: a gradient that varies from one color to another using a Gaussian distribution
	@available(iOS 13, macOS 10.15, *)
	static func gaussianGradient(center: CGPoint,
								 color0: CIColor = CIColor.white,
								 color1: CIColor = CIColor.clear,
								 radius: Float) -> CIImage {
		let filter = CIFilter.gaussianGradient() // CIGaussianGradient
		filter.center = center
		filter.color0 = color0
		filter.color1 = color1
		filter.radius = radius
		return filter.outputImage ?? CIImage.empty()
	}

	/// Hue/Saturation/Value Gradient
	///
	/// Generates a color wheel that shows hues and saturations for a specified value.
	///
	/// ⚠️ No Apple Documentation available for 'CIHueSaturationValueGradient'
	///
	/// Categories: Gradient, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - value: The color value used to generate the color wheel. (0...)
	///   - radius: The distance from the center of the effect. (0...)
	///   - softness: The softness of the generated color wheel. (0...)
	///   - dither: A Boolean value specifying whether the dither the generated output. (0...)
	///   - colorSpace: The CGColorSpaceRef that the color wheel should be generated in.
	/// - Returns: a color wheel that shows hues and saturations for a specified value
	@available(iOS 13, macOS 10.15, *)
	static func hueSaturationValueGradient(value: Float = 1,
										   radius: Float,
										   softness: Float = 1,
										   dither: Float = 1,
										   colorSpace: CGColorSpace = CGColorSpace(name: CGColorSpace.sRGB)!) -> CIImage {
		let filter = CIFilter.hueSaturationValueGradient() // CIHueSaturationValueGradient
		filter.value = value
		filter.radius = radius
		filter.softness = softness
		filter.dither = dither
		filter.colorSpace = colorSpace
		return filter.outputImage ?? CIImage.empty()
	}

	/// Lenticular Halo
	///
	/// Simulates a halo that is generated by the diffraction associated with the spread of a lens. This filter is typically applied to another image to simulate lens flares and similar effects.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CILenticularHaloGenerator)
	///
	/// Categories: Generator, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - color: A color.
	///   - haloRadius: The radius of the halo. (0...)
	///   - haloWidth: The width of the halo, from its inner radius to its outer radius. (0...)
	///   - haloOverlap: The separation of colors in the halo. (0...)
	///   - striationStrength: The intensity of the halo colors. Larger values are more intense. (0...)
	///   - striationContrast: The contrast of the halo colors. Larger values are higher contrast. (0...)
	///   - time: The duration of the effect. (0...1)
	/// - Returns: new `CIImage`
	@available(iOS 13, macOS 10.15, *)
	static func lenticularHaloGenerator(center: CGPoint,
										color: CIColor,
										haloRadius: Float,
										haloWidth: Float,
										haloOverlap: Float = 0.77,
										striationStrength: Float = 0.5,
										striationContrast: Float = 1,
										time: Float = 0) -> CIImage {
		let filter = CIFilter.lenticularHaloGenerator() // CILenticularHaloGenerator
		filter.center = center
		filter.color = color
		filter.haloRadius = haloRadius
		filter.haloWidth = haloWidth
		filter.haloOverlap = haloOverlap
		filter.striationStrength = striationStrength
		filter.striationContrast = striationContrast
		filter.time = time
		return filter.outputImage ?? CIImage.empty()
	}

	/// Linear Gradient
	///
	/// Generates a gradient that varies along a linear axis between two defined endpoints.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CILinearGradient)
	///
	/// Categories: Gradient, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - point0: The starting position of the gradient -- where the first color begins.
	///   - point1: The ending position of the gradient -- where the second color begins.
	///   - color0: The first color to use in the gradient.
	///   - color1: The second color to use in the gradient.
	/// - Returns: a gradient that varies along a linear axis between two defined endpoints
	@available(iOS 13, macOS 10.15, *)
	static func linearGradient(point0: CGPoint = .zero,
							   point1: CGPoint,
							   color0: CIColor = CIColor.white,
							   color1: CIColor = CIColor.black) -> CIImage {
		let filter = CIFilter.linearGradient() // CILinearGradient
		filter.point0 = point0
		filter.point1 = point1
		filter.color0 = color0
		filter.color1 = color1
		return filter.outputImage ?? CIImage.empty()
	}

	/// Mesh Generator
	///
	/// Generates a mesh from an array of line segments.
	///
	/// ⚠️ No Apple Documentation available for 'CIMeshGenerator'
	///
	/// Categories: Generator, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - width: The width in pixels of the effect. (0...)
	///   - color: A color.
	///   - mesh: An array of line segments stored as an array of CIVectors each containing a start point and end point.
	/// - Returns: a mesh from an array of line segments
	@available(iOS 13, macOS 10.15, *)
	static func meshGenerator(width: Float, color: CIColor = CIColor.white, mesh: [Any]) -> CIImage {
		let filter = CIFilter.meshGenerator() // CIMeshGenerator
		filter.width = width
		filter.color = color
		filter.mesh = mesh
		return filter.outputImage ?? CIImage.empty()
	}

	/// PDF417 Barcode Generator
	///
	/// Generates a PDF417 code (two-dimensional barcode) from input data.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIPDF417BarcodeGenerator)
	///
	/// Categories: Generator, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - message: The message to encode in the PDF417 Barcode
	///   - minWidth: The minimum width of the generated barcode in pixels. (56...583)
	///   - maxWidth: The maximum width of the generated barcode in pixels. (56...583)
	///   - minHeight: The minimum height of the generated barcode in pixels. (13...283)
	///   - maxHeight: The maximum height of the generated barcode in pixels. (13...283)
	///   - dataColumns: The number of data columns in the generated barcode (1...30)
	///   - rows: The number of rows in the generated barcode (3...90)
	///   - preferredAspectRatio: The preferred aspect ratio of the generated barcode (0...)
	///   - compactionMode: The compaction mode of the generated barcode. (0...3)
	///   - compactStyle: A Boolean that specifies whether to force a compact style Aztec code.
	///   - correctionLevel: The correction level ratio of the generated barcode (0...8)
	///   - alwaysSpecifyCompaction: A Boolean value specifying whether to force compaction style.
	/// - Returns: a PDF417 code (two-dimensional barcode) from input data
	@available(iOS 13, macOS 10.15, *)
	static func pdf417BarcodeGenerator(message: Data,
									   minWidth: Int,
									   maxWidth: Int,
									   minHeight: Int,
									   maxHeight: Int,
									   dataColumns: Int,
									   rows: Int,
									   preferredAspectRatio: Float,
									   compactionMode: Int,
									   compactStyle: Bool,
									   correctionLevel: Int,
									   alwaysSpecifyCompaction: Bool) -> CIImage {
		let filter = CIFilter.pdf417BarcodeGenerator() // CIPDF417BarcodeGenerator
		filter.message = message
		filter.minWidth = Float(minWidth)
		filter.maxWidth = Float(maxWidth)
		filter.minHeight = Float(minHeight)
		filter.maxHeight = Float(maxHeight)
		filter.dataColumns = Float(dataColumns)
		filter.rows = Float(rows)
		filter.preferredAspectRatio = preferredAspectRatio
		filter.compactionMode = Float(compactionMode)
		filter.compactStyle = Float(compactStyle ? 1 : 0)
		filter.correctionLevel = Float(correctionLevel)
		filter.alwaysSpecifyCompaction = Float(alwaysSpecifyCompaction ? 1 : 0)
		return filter.outputImage ?? CIImage.empty()
	}

	/// QR Code Generator
	///
	/// Generates a Quick Response code (two-dimensional barcode) from input data.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIQRCodeGenerator)
	///
	/// Categories: Generator, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - message: The message to encode in the QR Code
	///   - correctionLevel: QR Code correction level L, M, Q, or H.
	/// - Returns: a Quick Response code (two-dimensional barcode) from input data
	@available(iOS 13, macOS 10.15, *)
	static func qrCodeGenerator(message: Data, correctionLevel: String = "M") -> CIImage {
		let filter = CIFilter.qrCodeGenerator() // CIQRCodeGenerator
		filter.message = message
		filter.correctionLevel = correctionLevel
		return filter.outputImage ?? CIImage.empty()
	}

	/// Radial Gradient
	///
	/// Generates a gradient that varies radially between two circles having the same center. It is valid for one of the two circles to have a radius of 0.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIRadialGradient)
	///
	/// Categories: Gradient, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - radius0: The radius of the starting circle to use in the gradient. (0...)
	///   - radius1: The radius of the ending circle to use in the gradient. (0...)
	///   - color0: The first color to use in the gradient.
	///   - color1: The second color to use in the gradient.
	/// - Returns: a gradient that varies radially between two circles having the same center
	@available(iOS 13, macOS 10.15, *)
	static func radialGradient(center: CGPoint,
							   radius0: Float,
							   radius1: Float,
							   color0: CIColor = CIColor.white,
							   color1: CIColor = CIColor.black) -> CIImage {
		let filter = CIFilter.radialGradient() // CIRadialGradient
		filter.center = center
		filter.radius0 = radius0
		filter.radius1 = radius1
		filter.color0 = color0
		filter.color1 = color1
		return filter.outputImage ?? CIImage.empty()
	}

	/// Random Generator
	///
	/// Generates an image of infinite extent whose pixel values are made up of four independent, uniformly-distributed random numbers in the 0 to 1 range.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIRandomGenerator)
	///
	/// Categories: Generator, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	/// - Returns: an image of infinite extent whose pixel values are made up of four independent, uniformly-distributed random numbers in the 0 to 1 range
	@available(iOS 13, macOS 10.15, *)
	static func randomGenerator() -> CIImage {
		let filter = CIFilter.randomGenerator() // CIRandomGenerator

		return filter.outputImage ?? CIImage.empty()
	}

	/// Rounded Rectangle Generator
	///
	/// Generates a rounded rectangle image with the specified extent, corner radius, and color.
	///
	/// ⚠️ No Apple Documentation available for 'CIRoundedRectangleGenerator'
	///
	/// Categories: Generator, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that defines the extent of the effect.
	///   - radius: The distance from the center of the effect. (0...)
	///   - color: A color.
	/// - Returns: a rounded rectangle image with the specified extent, corner radius, and color
	@available(iOS 13, macOS 10.15, *)
	static func roundedRectangleGenerator(extent: CGRect, radius: Float, color: CIColor = CIColor.white) -> CIImage {
		let filter = CIFilter.roundedRectangleGenerator() // CIRoundedRectangleGenerator
		filter.extent = extent
		filter.radius = radius
		filter.color = color
		return filter.outputImage ?? CIImage.empty()
	}

	/// Rounded Rectangle Stroke Generator
	///
	/// Generates a rounded rectangle stroke image with the specified extent, corner radius, stroke width, and color.
	///
	/// ⚠️ No Apple Documentation available for 'CIRoundedRectangleStrokeGenerator'
	///
	/// Categories: Generator, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - extent: A rectangle that defines the extent of the effect.
	///   - radius: The distance from the center of the effect. (0...)
	///   - color: A color.
	///   - width: The width in pixels of the effect. (0...)
	/// - Returns: a rounded rectangle stroke image with the specified extent, corner radius, stroke width, and color
	@available(iOS 17, macOS 14.0, *)
	static func roundedRectangleStrokeGenerator(extent: CGRect,
												radius: Float,
												color: CIColor = CIColor.white,
												width: Float) -> CIImage {
		let filter = CIFilter.roundedRectangleStrokeGenerator() // CIRoundedRectangleStrokeGenerator
		filter.extent = extent
		filter.radius = radius
		filter.color = color
		filter.width = width
		return filter.outputImage ?? CIImage.empty()
	}

	/// Smooth Linear Gradient
	///
	/// Generates a gradient that uses an S-curve function to blend colors along a linear axis between two defined endpoints.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISmoothLinearGradient)
	///
	/// Categories: Gradient, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - point0: The starting position of the gradient -- where the first color begins.
	///   - point1: The ending position of the gradient -- where the second color begins.
	///   - color0: The first color to use in the gradient.
	///   - color1: The second color to use in the gradient.
	/// - Returns: a gradient that uses an S-curve function to blend colors along a linear axis between two defined endpoints
	@available(iOS 13, macOS 10.15, *)
	static func smoothLinearGradient(point0: CGPoint = .zero,
									 point1: CGPoint,
									 color0: CIColor = CIColor.white,
									 color1: CIColor = CIColor.black) -> CIImage {
		let filter = CIFilter.smoothLinearGradient() // CISmoothLinearGradient
		filter.point0 = point0
		filter.point1 = point1
		filter.color0 = color0
		filter.color1 = color1
		return filter.outputImage ?? CIImage.empty()
	}

	/// Star Shine
	///
	/// Generates a starburst pattern that is similar to a supernova; can be used to simulate a lens flare.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIStarShineGenerator)
	///
	/// Categories: Generator, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - color: The color to use for the outer shell of the circular star.
	///   - radius: The radius of the star. (0...)
	///   - crossScale: The size of the cross pattern. (0...)
	///   - crossAngle: The angle in radians of the cross pattern.
	///   - crossOpacity: The opacity of the cross pattern. (-8...)
	///   - crossWidth: The width of the cross pattern. (0...)
	///   - epsilon: The length of the cross spikes. (-8...)
	/// - Returns: a starburst pattern that is similar to a supernova; can be used to simulate a lens flare
	@available(iOS 13, macOS 10.15, *)
	static func starShineGenerator(center: CGPoint,
								   color: CIColor,
								   radius: Float,
								   crossScale: Float = 15,
								   crossAngle: Float = 0.6,
								   crossOpacity: Float = -2,
								   crossWidth: Float,
								   epsilon: Float = -2) -> CIImage {
		let filter = CIFilter.starShineGenerator() // CIStarShineGenerator
		filter.center = center
		filter.color = color
		filter.radius = radius
		filter.crossScale = crossScale
		filter.crossAngle = crossAngle
		filter.crossOpacity = crossOpacity
		filter.crossWidth = crossWidth
		filter.epsilon = epsilon
		return filter.outputImage ?? CIImage.empty()
	}

	/// Stripes
	///
	/// Generates a stripe pattern. You can control the color of the stripes, the spacing, and the contrast.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CIStripesGenerator)
	///
	/// Categories: Generator, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - color0: A color to use for the odd stripes.
	///   - color1: A color to use for the even stripes.
	///   - width: The width of a stripe.
	///   - sharpness: The sharpness of the stripe pattern. The smaller the value, the more blurry the pattern. Values range from 0.0 to 1.0. (0...1)
	/// - Returns: a stripe pattern
	@available(iOS 13, macOS 10.15, *)
	static func stripesGenerator(center: CGPoint,
								 color0: CIColor = CIColor.white,
								 color1: CIColor = CIColor.black,
								 width: Float,
								 sharpness: Float = 1) -> CIImage {
		let filter = CIFilter.stripesGenerator() // CIStripesGenerator
		filter.center = center
		filter.color0 = color0
		filter.color1 = color1
		filter.width = width
		filter.sharpness = sharpness
		return filter.outputImage ?? CIImage.empty()
	}

	/// Sunbeams
	///
	/// Generates a sun effect. You typically use the output of the sunbeams filter as input to a composite filter.
	///
	/// [Documentation](https://t.ly/Gyd6#//apple_ref/doc/filter/ci/CISunbeamsGenerator)
	///
	/// Categories: Generator, Video, Still Image, High Dynamic Range, Built-In
	///
	///
	/// - Parameters:
	///   - center: The center of the effect as x and y pixel coordinates.
	///   - color: The color of the sun.
	///   - sunRadius: The radius of the sun. (0...)
	///   - maxStriationRadius: The radius of the sunbeams. (0...)
	///   - striationStrength: The intensity of the sunbeams. Higher values result in more intensity. (0...)
	///   - striationContrast: The contrast of the sunbeams. Higher values result in more contrast. (0...)
	///   - time: The duration of the effect. (0...1)
	/// - Returns: a sun effect
	@available(iOS 13, macOS 10.15, *)
	static func sunbeamsGenerator(center: CGPoint,
								  color: CIColor,
								  sunRadius: Float,
								  maxStriationRadius: Float = 2.58,
								  striationStrength: Float = 0.5,
								  striationContrast: Float = 1.375,
								  time: Float = 0) -> CIImage {
		let filter = CIFilter.sunbeamsGenerator() // CISunbeamsGenerator
		filter.center = center
		filter.color = color
		filter.sunRadius = sunRadius
		filter.maxStriationRadius = maxStriationRadius
		filter.striationStrength = striationStrength
		filter.striationContrast = striationContrast
		filter.time = time
		return filter.outputImage ?? CIImage.empty()
	}

	/// Text Image Generator
	///
	/// Generate an image from a string and font information.
	///
	/// ⚠️ No Apple Documentation available for 'CITextImageGenerator'
	///
	/// Categories: Generator, Video, Still Image, Built-In
	///
	///
	/// - Parameters:
	///   - text: The text to render.
	///   - fontName: The name of the font to use for the generated text.
	///   - fontSize: The size of the font to use for the generated text. (0...)
	///   - scaleFactor: The scale of the font to use for the generated text. (0...)
	///   - padding: The number of additional pixels to pad around the text’s bounding box. (0...200)
	/// - Returns: an image from a string and font information
	@available(iOS 16, macOS 13.0, *)
	static func textImageGenerator(text: String,
								   fontName: String = "HelveticaNeue",
								   fontSize: Float = 12,
								   scaleFactor: Float = 1,
								   padding: Int) -> CIImage {
		let filter = CIFilter.textImageGenerator() // CITextImageGenerator
		filter.text = text
		filter.fontName = fontName
		filter.fontSize = fontSize
		filter.scaleFactor = scaleFactor
		filter.padding = Float(padding)
		return filter.outputImage ?? CIImage.empty()
	}
}


